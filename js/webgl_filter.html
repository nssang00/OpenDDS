<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL GeoJSON Rendering</title>
</head>
<body>
  <canvas id="webglCanvas" width="800" height="600"></canvas>
  <script>
    // Sample GeoJSON data
    const geojson = {
      type: "FeatureCollection",
      features: [
        {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: [[-0.5, -0.5], [0.0, 0.5], [0.5, -0.5]]
          },
          properties: {
            color: [1.0, 0.0, 0.0], // Red
            width: 0.05
          }
        },
        {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: [[-0.8, 0.2], [-0.4, 0.6], [0.0, 0.2]],
          },
          properties: {
            color: [0.0, 1.0, 0.0], // Green
            width: 0.1
          }
        }
      ]
    };

    // Parse GeoJSON to generate buffers for WebGL
    function parseGeoJSONWithThickness(geojson) {
      const vertices = [];
      const indices = [];
      const colors = [];

      geojson.features.forEach((feature, featureID) => {
        const { coordinates } = feature.geometry;
        const { color, width } = feature.properties;

        for (let i = 0; i < coordinates.length - 1; i++) {
          const start = coordinates[i];
          const end = coordinates[i + 1];

          // Vector from start to end
          const dx = end[0] - start[0];
          const dy = end[1] - start[1];
          const length = Math.sqrt(dx * dx + dy * dy);

          // Perpendicular vector for thickness
          const px = -dy / length * width;
          const py = dx / length * width;

          // Create 4 vertices for the quad (two triangles)
          const v1 = [start[0] - px, start[1] - py, 0.0];
          const v2 = [start[0] + px, start[1] + py, 0.0];
          const v3 = [end[0] - px, end[1] - py, 0.0];
          const v4 = [end[0] + px, end[1] + py, 0.0];

          // Push vertices
          vertices.push(...v1, ...v2, ...v3, ...v4);

          // Add color for each vertex
          colors.push(...color, ...color, ...color, ...color);

          // Add indices for two triangles
          const baseIndex = vertices.length / 3 - 4;
          indices.push(
            baseIndex, baseIndex + 1, baseIndex + 2,
            baseIndex + 1, baseIndex + 3, baseIndex + 2
          );
        }
      });

      return { vertices, indices, colors };
    }

    // Upload data to WebGL buffers
    function uploadToWebGL(gl, data) {
      // Vertex Buffer
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertices), gl.STATIC_DRAW);

      // Color Buffer
      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.colors), gl.STATIC_DRAW);

      // Index Buffer
      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data.indices), gl.STATIC_DRAW);

      return { vertexBuffer, colorBuffer, indexBuffer };
    }

    // Create shader
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    // Create WebGL program
    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    // Render WebGL
    function renderWebGL(gl, buffers, program, data) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertexBuffer);
      const positionLocation = gl.getAttribLocation(program, 'position');
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.colorBuffer);
      const colorLocation = gl.getAttribLocation(program, 'color');
      gl.enableVertexAttribArray(colorLocation);
      gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indexBuffer);

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawElements(gl.TRIANGLES, data.indices.length, gl.UNSIGNED_SHORT, 0);
    }

    // Main function
    function main() {
      const canvas = document.getElementById('webglCanvas');
      const gl = canvas.getContext('webgl');

      const vertexShaderSource = `
        attribute vec3 position;
        attribute vec3 color;
        varying vec3 vColor;
        void main() {
          vColor = color;
          gl_Position = vec4(position, 1.0);
        }
      `;

      const fragmentShaderSource = `
        precision mediump float;
        varying vec3 vColor;
        void main() {
          gl_FragColor = vec4(vColor, 1.0);
        }
      `;

      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
      const program = createProgram(gl, vertexShader, fragmentShader);

      const data = parseGeoJSONWithThickness(geojson);
      const buffers = uploadToWebGL(gl, data);

      gl.useProgram(program);
      renderWebGL(gl, buffers, program, data);
    }

    main();
  </script>
</body>
</html>
