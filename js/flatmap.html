
function createStyledOlLayers(styleObj, layersObj) {
  return layersObj.map(layerObj => {
    if (layerObj.layers) {
      return new LayerGroup({
        layers: createStyledOlLayers(styleObj, layerObj.layers)
      });
    }

    const vectorTileSource = new VectorTileSource({
      format: new MVT(),
      url: layerObj.source
    });

    const layers = layerObj.rules.flatMap(rule =>
      rule.styleNames.flatMap(styleName =>
        [...(Array.isArray(styleObj[styleName]) ? styleObj[styleName] : [styleObj[styleName]])].map(style =>
          createStyledLayer({
            style: {...style, filter: rule.filter},
            source: vectorTileSource
          })
        )
      )
    );

    return layers.length === 1 ? layers[0] : new LayerGroup({ layers });
  });
}

function createStyledLayer({ style, source }) {
  if (typeof style === 'function') {
    return new VectorTileLayer({
      source: source,
      style: style
    });
  } else {
    return new (class extends VectorTileLayer {
      createRenderer() {
        return new WebGLVectorTileLayerRenderer(this, {
          style: style
        });
      }
    })({
      source: source
    });
  }
}

function createStyledOlLayers(styleObj, layersObj) {
  return layersObj.map(layerObj => {
    if (layerObj.layers) {
      return new LayerGroup({
        layers: createStyledOlLayers(styleObj, layerObj.layers)
      });
    }

    const vectorTileSource = new VectorTileSource({
      format: new MVT(),
      url: layerObj.source
    });

    const layers = layerObj.rules.flatMap(rule =>
      rule.styleNames.map(styleName =>
        createStyledLayer({
          style: {
            ...styleObj[styleName], // Original style
            filter: rule.filter      // Add the filter directly
          },
          source: vectorTileSource
        })
      )
    );
/*
const layers = layerObj.rules.flatMap(rule =>
      rule.styleNames.flatMap(styleName => {
        const styles = Array.isArray(styleObj[styleName]) 
          ? styleObj[styleName] 
          : [styleObj[styleName]];  // Wrap single object in array if necessary

        return styles.map(style =>
          createStyledLayer({
            style: {
              ...style,       // Original style
              filter: rule.filter  // Add the filter directly
            },
            source: vectorTileSource
          })
        );
      })
    );
*/
    return layers.length === 1 ? layers[0] : new LayerGroup({ layers });
  });
}

///////

class WebGLVectorTileLayerRenderer {
  constructor(layer, options) {
    this.layer = layer;    // 레이어 저장
    this.style = options.style;    // 스타일 저장
  }
}

class VectorTileLayer {
  constructor(options) {
    this.source = options.source;    // 소스 저장
    this.style = options.style;      // 스타일 저장
  }

  createRenderer() {
    // WebGLVectorTileLayerRenderer를 생성해 반환
    return new WebGLVectorTileLayerRenderer(this, {
      style: this.style
    });
  }
}

// 테스트용 함수
function createStyledLayer({ style, source }) {
  const layer = new VectorTileLayer({
    source: source,
    style: style
  });

  // createRenderer로 WebGLVectorTileLayerRenderer 생성
  const renderer = layer.createRenderer();

  return {
    layer,
    renderer
  };
}

const styleObj = {
  "AL015A08": [
    {
      "style": {
        "fill-color": [255,255,255,0],
        "stroke-pattern-src": "No_Fish.png",
        "stroke-width": null,
        "stroke-pattern-start-offset": null,
        "stroke-pattern-spacing": null
      }
    }
  ],
  "AL015A05": [
    {
      "style": {
        "fill-pattern-src": "aaa.png",
        "stroke-pattern-src": "No_Fish.png",
        "stroke-width": null,
        "stroke-pattern-start-offset": null,
        "stroke-pattern-spacing": null
      },
      "symbol": {
        "type": "polygon",
        "polygon-picture-texture-fill": true
      }
    }
  ]
};

const layersObj = [
  {
    "name": "암초",
    "source": "PBD130",
    "rules": [
      {
        "styleNames": ["BD130P01"],
        "filter": [
          "all",
          ["<=", ["resolution"], 611.49622628141],
          [">", ["resolution"], 152.8740565703525],
          ["in", ["get", "VRR"], [0, 1, 8]]
        ]
      },
      {
        "styleNames": ["BD130P02"],
        "filter": [
          "all",
          ["<=", ["resolution"], 611.49622628141],
          [">", ["resolution"], 152.8740565703525],
          ["in", ["get", "VRR"], [2, 4]]
        ]
      }
    ]
  }
];

// createStyledOlLayers 함수 내 styles 부분
const styles = layersObj[0].rules.flatMap(rule =>
  rule.styleNames.map(styleName => {
    // Get the corresponding style object from styleObj
    const style = styleObj[styleName];
    
    // If the style is found, include the filter from the rule
    return style ? style.map(style => ({
      ...style, // Include the original style
      filter: rule.filter // Add the filter from the rule
    })) : [];
  })
);

console.log(styles);

const stylesWithFilter = layersObj[0].rules.flatMap(rule =>
  rule.styleNames.flatMap(styleName => {
    const styles = Array.isArray(styleObj[styleName]) 
      ? styleObj[styleName] 
      : [styleObj[styleName]];  // Wrap single object in array if necessary

    return styles.map(style => ({
      ...style,  // Spread the style object
      filter: rule.filter  // Add the filter from the rule
    }));
  })
);

console.log(stylesWithFilter);            



console.log(styles);
// [function() { /* 스타일 함수 */ }, { /* 스타일 객체 */ }]
