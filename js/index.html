<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Sandbox</title>
    <meta charset="UTF-8" />
  </head>

  <body>
    <div id="app"></div>
    <script>
const xmlMapStyle = `<MapStyle Version="1.0">	
	<Style name="Agg" type="point">
		<OffsetX>0</OffsetX>
		<OffsetY>0</OffsetY>
		<PointLayer type="PICTURE">
			<Picture>ddd.png</Picture>
		</PointLayer>
	</Style>  
	<Style name="Agg2" type="point">
		<OffsetX>0</OffsetX>
		<OffsetY>0</OffsetY>
    <PointLayer type="SIMPLE">
    <Color>255, 0, 99, 198</Color>
    <Size>6</Size>
    <Shape>0</Shape>
		</PointLayer>
	</Style>    
  <Style name="BB010T03" type="Label">
		<Font>굴림</Font>
		<Size>8</Size>
		<Color>255, 97, 17, 146</Color>
		<Bold>false</Bold>
		<Italic>false</Italic>
		<Underline>false</Underline>
		<OffsetX>23</OffsetX>
		<OffsetY>-2</OffsetY>
		<Align>4</Align>
	</Style>

	<Style name="Adfs" type="line">
		<LineLayer type="DASH">
			<Color>255, 0, 0, 0</Color>
			<Width>1</Width>
			<JoinType>2</JoinType>
			<Dash>
				<DashItem>6</DashItem>
				<DashItem>3</DashItem>
				<DashItem>6</DashItem>
				<DashItem>3</DashItem>
			</Dash>
		</LineLayer>
		<LineLayer type="PICTURE">
			<Picture>dfd.png</Picture>
			<TextureLine>false</TextureLine>
			<Width>8</Width>
		</LineLayer>		
	</Style>
	<Style name="AL015A08" type="polygon">
		<PolygonLayer type="SIMPLE">
			<Color>255, 255, 255, 255</Color>
			<Transparent>true</Transparent>
			<LineLayer type="PICTURE">
				<Picture>No_Fish.png</Picture>
				<TextureLine>false</TextureLine>
			</LineLayer>
		</PolygonLayer>
  </Style>
</MapStyle>`;

const xmlMapLayer = `<MapLayer Version="1.0">
	<Layer Category="경계" Name="해안선" FACC="BA010" GeometryType="Line" SHPSource="LBA010" GDBSource="CoastL" Map="250K,500K,1M" DisplayType="Geometry">
		<Feature Name="사구" Description="설명" GeometryStyle="BA010L01">
			<VVTStyle ACC="0" SLT="0,10,11,13"></VVTStyle>
		</Feature>
		<Feature Name="사구" Description="설명" GeometryStyle="BA010L02">
			<VVTStyle ACC="0" SLT="0,10,11,13"></VVTStyle>
		</Feature>
	</Layer>
	<Layer Category="고도" Name="표고점" FACC="CA030" GeometryType="Point" SHPSource="PCA010" GDBSource="ElevP" Map="250K,500K,1M" DisplayType="Both" LabelColumn="ZV2">
		<Feature Name="명확한 표고점" Description="설명" GeometryStyle="CA030P01" LabelStyle="CA030T01">
			<VVTStyle ACC="1" ELA="0,2"></VVTStyle>
		</Feature>
		<Feature Name="명확한 표고점" Description="설명" GeometryStyle="CA030P01" LabelStyle="CA030T02">
			<VVTStyle ACC="1" ELA="0,2"></VVTStyle>
		</Feature>		
	</Layer>
	<Group Category="연안수부지물" Name="간석지" GeometryType="Point">
    <Layer Category="수부" Name="암초" FACC="BD130" GeometryType="Point" SHPSource="PBD130" GDBSource="DangerP" Map="250K,500K,1M" DisplayType="Geometry">
		<Feature Name="수상암초" Description="설명" GeometryStyle="BD130P01">
			<VVTStyle VRR="0,1,8"></VVTStyle>
		</Feature>
		<Feature Name="수중암초" Description="설명" GeometryStyle="BD130P02">
			<VVTStyle VRR="2,4"></VVTStyle>
		</Feature>		
	</Layer>	    
	</Group>  
</MapLayer>`;



function parseMapStyle(xmlString) {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlString, "text/xml");

  let styles = [];

  for (const styleNode of xmlDoc.documentElement.children) {//Style
    styles.push(parseStyleNode(styleNode));
  }

  return styles;

  function parseStyleNode(node) {
    const nodeObj = {};
    for (const attr of node.attributes) {
      nodeObj[attr.name] = attr.value;
    }

    let children = [];
    for (let child of node.children) {

      if(['PointLayer', 'LineLayer', 'PolygonLayer'].includes(child.tagName)) {
        children.push(parseStyleNode(child));
      }  else {
        if (child.children.length === 0) {
          nodeObj[child.tagName] = child.textContent;
        } else {//Dash
          nodeObj[child.tagName] = [];
          for (const item of child.children) {
            nodeObj[child.tagName].push(item.textContent);
          }
        }
      }
    }

    if (children.length > 0) {
      nodeObj.symbolizers = children;
    }

    return nodeObj;
  }
}


function parseMapLayer(xmlString) {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlString, "text/xml");

  const layers = [];
  const groups = [];

  for (const child of xmlDoc.documentElement.children) {
    let nodeObj = parseLayerNode(child);
    if (child.tagName === "Group") {
      groups.push(nodeObj);
    } else if (child.tagName === "Layer") {
      layers.push(nodeObj);
    }
  }

  return {
    layers,
    groups
  };

  function parseLayerNode(node) {
    const nodeObj = {};
    for (const attr of node.attributes) {
      nodeObj[attr.name] = attr.value;
    }

    let children = [];
    for (let child of node.children) {

      if(child.children.length > 0) {
        children.push(parseLayerNode(child));
      } else {
        const childObj = {};
        for(const attr of child.attributes) {
          childObj[attr.name] = attr.value;
        }
        nodeObj[child.tagName] = childObj;        
      }
    }

    if (children.length > 0) {
      if (node.tagName === "Group") {
        nodeObj.layers = children;
      } else if (node.tagName === "Layer") {
        nodeObj.features = children;
      }

    }
    return nodeObj;
  }   
}

function toOlStyle(styles) {

  for (const styleObj of styles) {
    switch (styleObj.type) {
      case "point":
        toOlPointStyle(styleObj);
        break;
      case "line":
        //symbolizers = parseLineLayers(styleNode);
        break;
      case "polygon":
        //symbolizers = parsePolygonLayers(styleNode);
        break;
      case "Label":
        //symbolizers = parseLabelLayers(styleNode);
        break;
      default:
        break;
    }
  }
/*
  {
    "name": "Agg",
    "type": "point",
    "OffsetX": "0",
    "OffsetY": "0",
    "symbolizers": [
      {
        "type": "PICTURE",
        "Picture": "ddd.png"
      }
    ]
  },
  {
    "name": "Agg2",
    "type": "point",
    "OffsetX": "0",
    "OffsetY": "0",
    "symbolizers": [
      {
        "type": "SIMPLE",
        "Color": "255, 0, 0, 0",
        "Size": "6",
        "Shape": "1"
      }
    ]
  },  
*/
  function toOlPointStyle(pointObj) {

    const offset = [Number(pointObj.OffsetX), Number(pointObj.OffsetY)];    
    for(const symbolizer of pointObj.symbolizers)
    {
      switch (symbolizer.type) {
        case "SIMPLE":
          let [a, r, g, b] = symbolizer.Color.split(',').map(Number);
          const rgba = [r, g, b, parseFloat(a/255).toFixed(2)];
          if(symbolizer.Shape === "0")//Circle
          {
            return {//<Shape> : 0
              'circle-radius': symbolizer.Size,//<Size>
              'circle-fill-color': rgba,//<Color>
              'circle-displacement': offset,//<OffsetX>, <OffsetY>
            };
          }
          else if(symbolizer.Shape === "1")//Rectangle
          {
            return {//<Shape> : 1
              'shape-points': 4,
              'shape-radius': symbolizer.Size,//<Size>
              'shape-fill-color': rgba,//<Color>
              'shape-displacement': offset,//<OffsetX>, <OffsetY>
              'shape-angle': Math.PI / 4,
            };
          }
          break;
        case "PICTURE":
          return {
            'icon-src': symbolizer.Picture,//<Picture>
            'icon-displacement': offset,//<OffsetX>, <OffsetY>
            //'icon-width': 20,
            //'icon-height': 20,
          };
          break;
        default:
          break;
      }
    }
  }

/*
  {
    "name": "Adfs",
    "type": "line",
    "symbolizers": [
      {
        "type": "DASH",
        "Color": "255, 0, 0, 0",
        "Width": "1",
        "JoinType": "2",
        "Dash": ["6","3","6","3"]
      },
      {
        "type": "PICTURE",
        "Picture": "dfd.png",
        "TextureLine": "false",
        "Width": "8"
      }
    ]
  },  
*/


  //SIMPLE, DASH, PICTURE, VERTICAL, DOUBLELINE
  function toOlLineStyle(lineObj) {

    const lineJoins = ['miter', 'bevel', 'round'];//JoinType
    const lineCaps = ['butt', 'square', 'round'];//StartCap

    let rgba;
    if(symbolizer.Color)
    {
      const [a, r, g, b] = symbolizer.Color.split(',').map(Number);
      rgba = [r, g, b, parseFloat(a/255).toFixed(2)];  
    }

    const styles = [];
    for(const symbolizer of lineObj.symbolizers)
    {
      switch (symbolizer.type) {
        case "SIMPLE":        
          styles.push({
            'stroke-color': rgba,//<Color>
            'stroke-width': symbolizer.Width,//<Width>
            'stroke-line-join': lineJoins[Number(symbolizer.JoinType)],//<JoinType> 0:miter, 1:bevel, 2:round
            'stroke-line-cap': lineCaps[Number(symbolizer.StartCap)],//<StartCap>, <EndCap> 0:butt, 1:square, 2:round
          });          
          break;
        case "DASH":
          let dasharray = symbolizer.Dash.map(Number);
          styles.push({
            'stroke-color': rgba,//<Color>
            'stroke-width': symbolizer.Width,//<Width>
            'stroke-line-join': lineJoins[Number(symbolizer.JoinType)],//<JoinType> 0:miter, 1:bevel, 2:round
            'stroke-line-cap': lineCaps[Number(symbolizer.StartCap)],//<DashCap> 0:butt, 1:round
            'stroke-line-dash-offset': symbolizer.DashOffset,//<DashOffset>  
            'stroke-line-dash': dasharray,//<Dash><DashItem>
          });      
          break;
        case "PICTURE":
          if(symbolizer.TextureLine === "false")//
          {
            styles.push({
              'symbol-picture-texture-line': false,//<TextureLine>
              'stroke-pattern-src': symbolizer.Picture,//<Picture>
              'stroke-width': symbolizer.Width,//<Width>
              'stroke-pattern-start-offset': Number(symbolizer.StartPos), //<StartPos>  
              'stroke-pattern-spacing': Number(symbolizer.Interval),//<Interval>  
            });        
          }
          else if(symbolizer.TextureLine === "true")//StrokePattern, stylefunction, canvas
          {
            styles.push({
              'symbol-picture-texture-line': true,//<TextureLine>              
              'stroke-pattern-src': symbolizer.Picture,//<Picture>
              //'icon-src': symbolizer.Picture,//<Picture>
              'stroke-width': Number(symbolizer.Width),//<Width>
              'stroke-line-join': lineJoin[Number(symbolizer.JoinType)],//<JoinType> 0:miter, 1:bevel, 2:round
              'stroke-line-cap': lineCap[Number(symbolizer.StartCap)],//<DashCap> 0:butt, 1:round
            });     
          }
          break;
        case "VERTICAL":
          styles.push({
            'symbol-vertical-color': `rgba(${rgba.join('')})`,//<Color>
            'symbol-vertical-width': Number(symbolizer.Width),//<Width>
            'symbol-vertical-vertical-type': Number(symbolizer.VerticalType),//<VerticalType>
            'symbol-vertical-left-length': Number(symbolizer.leftLength),//<LeftLength>
            'symbol-vertical-right-length': Number(symbolizer.rightLength),//<RightLength>
            'symbol-vertical-line-cap': Number(symbolizer?.StartCap),//<StartCap>, <EndCap>
            'symbol-vertical-start-pos': Number(symbolizer?.StartPos),//<StartPos>  
            'symbol-vertical-interval': Number(symbolizer?.Interval),//<Interval>                     
          });              
/*
          const symbol = drawVerticalSymbol({
            color: `rgba(${rgba.join('')})`,//<Color>
            width: symbolizer.Width,//<Width>
            verticalType: symbolizer.VerticalType,//<VerticalType>
            leftLength: symbolizer.leftLength,//<LeftLength>
            rightLength: symbolizer.rightLength, //<RightLength>
            lineCap: symbolizer?.StartCap,//<StartCap>, <EndCap>
          });
          lines.push({
            'stroke-pattern-src': symbol.src,
            'stroke-width': symbol.strokeWidth,
            'stroke-offset': 0,
            'stroke-pattern-start-offset': symbolizer.StartPos, //<StartPos>  
            'stroke-pattern-spacing': symbolizer.Interval,//<Interval>    
          });
          */
          break;         
        case "DOUBLELINE":
          styles.push({
            'symbol-double-line-color': rgba,//<Color>
            'symbol-double-line-width': symbolizer.Width,//<Width>
            'symbol-double-line-type': symbolizer.Type,//<Type>
            'symbol-double-line-space': Number(symbolizer.Shape), //<Space>
            'symbol-double-line-line-join': lineJoins[Number(symbolizer.JoinType)],//<JoinType> 0:miter, 1:bevel, 2:round
          });        
          /*      
          if(symbolizer.Type === 0)//Simple
          {           
            
            lines.push({
              'stroke-color': rgba,//<Color>
              'stroke-width': symbolizer.Width,//<Width>
              'stroke-offset': Number(symbolizer.Shape)/2, //<Space>/2
              'stroke-line-join': lineJoins[Number(symbolizer.JoinType)],//<JoinType> 0:miter, 1:bevel, 2:round
            });   
            lines.push({
              'stroke-color': rgba,//<Color>
              'stroke-width': symbolizer.Width,//<Width>
              'stroke-offset': -Number(symbolizer.Shape)/2, //<Space>/2
              'stroke-line-join': lineJoins[Number(symbolizer.JoinType)],//<JoinType> 0:miter, 1:bevel, 2:round
            }); 
          }
          else if(symbolizer.Type === 2)//Bridge //StrokePattern, stylefunction, canva, + doubleline(simple)
          {

          }
          else if(symbolizer.Type === 3)//Left Only
          {
            lines.push({
              'stroke-color': rgba,//<Color>
              'stroke-width': symbolizer.Width,//<Width>
              'stroke-offset': Number(symbolizer.Shape)/2, //<Space>/2
              'stroke-line-join': lineJoins[Number(symbolizer.JoinType)],//<JoinType> 0:miter, 1:bevel, 2:round
            });   
          }
          else if(symbolizer.Type === 4)//Right Only
          {
            lines.push({
              'stroke-color': rgba,//<Color>
              'stroke-width': symbolizer.Width,//<Width>
              'stroke-offset': -Number(symbolizer.Shape)/2, //<Space>/2
              'stroke-line-join': lineJoins[Number(symbolizer.JoinType)],//<JoinType> 0:miter, 1:bevel, 2:round
            });  
          }
          else if(symbolizer.Type === 5)//Tunnel //StrokePattern, stylefunction, canva
          {
            
          }
          else if(symbolizer.Type === 6)//PipeLine //StrokePattern, stylefunction, canva
          {
            
          } */     
          break;                 
        default:
          break;
      }
    }
  }  

  function toOlPolygonStyle(polygonObj) {
 
    const styles = [];
    for(const symbolizer of polygonObj.symbolizers)
    {

      if(symbolizer.type === "SIMPLE")
      {
        let [a, r, g, b] = symbolizer.Color.split(',').map(Number);
        const rgba = [r, g, b, parseFloat(a/255).toFixed(2)];

        if(symbolizer.Transparent === "true")
          rgba[3] = 0;//alpha -> 0
        
        let polygonStyleObj = 
        {
          'fill-color': rgba,
        };
        Object.assign(polygonStyleObj, toOlLineLayer(symbolizer.symbolizers));
        styles.push(polygonStyleObj);
      }
      else if(symbolizer.type === "PICTURE")
      {
        let polygonStyleObj = 
        {
          'fill-pattern-src': symbolizer.Picture,//<Picture>
          'symbol-picture-texture-fill': symbolizer.TextureFill//<TextureFill>
        };
        Object.assign(polygonStyleObj, toOlLineLayer(symbolizer.symbolizers));
        styles.push(polygonStyleObj);
      }
    }
    return styles;
  }

  function toOlLabelStyle(labelObj) {

    const size = Number(labelObj.Size);
    const offsetX = Number(labelObj.OffsetX);
    const offsetY = Number(labelObj.OffsetY);
    const bold = Boolean(labelObj.Bold);
    const italic = Boolean(labelObj.Italic);
    const underline = Boolean(labelObj.Underline)
    const textAlign = Number(labelObj.Align);
    const textAligns = [
      ['left', 'top'],      //0
      ['center', 'top'],    //1
      ['right', 'top'],     //2
      ['left', 'middle'],   //3
      ['center', 'middle'], //4
      ['right', 'middle'],  //5
      ['left', 'bottom'],   //6
      ['center', 'bottom'], //7
      ['right', 'bottom'],  //8   
    ];
    const align = textAligns[textAlign][0];
    const baseline = textAligns[textAlign][1];

    let [a, r, g, b] = symbolizer.Color.split(',').map(Number);
    const fillColor = [r, g, b, parseFloat(a/255).toFixed(2)];
    
    const labelStyleObj = {
      'text-font': (bold ? 'bold ':'') + (italic ? 'italic ':'') + size + 'px ' + font,//Font, Size, Bold, Italic
      'text-fill-color': fillColor,//Color
      'text-align': align,//Align
      'text-baseline': baseline,//Align
      'text-offset-x': offsetX,//OffsetX
      'text-offset-y': offsetY,//OffsetY

      'label-underline': underline,
      'label-sea-water-level': Boolean(labelObj.SeaWaterLevel),
      'label-decimal': Number(labelObj.Decimal),
      'label-prefix': labelObj.Prefix,
      'label-postfix': labelObj.Postfix,
    }
    if(Boolean(labelObj.Outline))
    {
      let [a, r, g, b] = symbolizer.OutlineColor.split(',').map(Number);
      const outlineColor = [r, g, b, parseFloat(a/255).toFixed(2)];      
      labelStyleObj['text-stroke-color'] = outlineColor
    }
    if(Boolean(labelObj.Box))
    {
      let [a, r, g, b] = symbolizer.BoxColor.split(',').map(Number);
      const boxColor = [r, g, b, parseFloat(a/255).toFixed(2)];      
      labelStyleObj['text-background-fill-color'] = boxColor
    }
    const picture = symbolizer?.Picture;
    if(picture)
    {
      labelStyleObj['icon-src'] = picture;
      labelStyleObj['icon-displacement'] = [Number(symbolizer.ImageOffsetX), Number(pointObj.ImageOffsetY)];  
      labelStyleObj['label-image-align'] = picture;symbolizer.ImageAlign
    }

    return labelStyleObj;
  }  

}

const textAligns = [
  ['left',      'top'],      //0
  ['center',    'top'],    //1
  ['right',     'top'],     //2
  ['left',   'middle'],   //3
  ['center', 'middle'], //4
  ['right',   'middle'],  //5
  ['left',    'bottom'],   //6
  ['center',  'bottom'], //7
  ['right',   'bottom'],  //8   
];



  

function formatString(input, prefix, postfix, decimal, underline) {
  let result = prefix + input + postfix;

  if (decimal >= 0) {
    const num = parseFloat(input);
    if (!isNaN(num)) {
      result = prefix + num.toFixed(decimal) + postfix;
    }
  }

  if (underline) {
    result = result.split('').map(char => char + '\u0332').join('');
  }
  return result;
}

function createFontString(bold, italic, size, font) {
  return (bold ? 'bold ':'') + (italic ? 'italic ':'') + size + 'px ' + font;
}

let results = parseMapStyle(xmlMapStyle);

toOlStyle(results);
console.log(JSON.stringify(results, null, 2));

let results2 = parseMapLayer(xmlMapLayer);

console.log(JSON.stringify(results2, null, 2));

    </script>
  </body>
</html>
