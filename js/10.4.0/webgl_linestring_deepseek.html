<!DOCTYPE html>
<html>
<head>
    <title>WebGL Dashed Line</title>
    <style>
        canvas { border: 1px solid black; }
    </style>
</head>
<body>
    <canvas id="glCanvas" width="500" height="500"></canvas>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }

        // LineString 데이터
        const lineString = {
            type: "LineString",
            coordinates: [[10.2, 1.0], [10.3, 2.0], [10.4, 2.5]]
        };

        // 좌표를 클립 공간으로 변환
        function transformCoordinates(coords) {
            const xs = coords.map(c => c[0]);
            const ys = coords.map(c => c[1]);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;
            
            return coords.map(c => {
                let x = ((c[0] - minX) / rangeX) * 2 - 1;
                let y = ((c[1] - minY) / rangeY) * 2 - 1;
                x *= 0.9; // 패딩 적용
                y *= 0.9;
                return [x, y];
            });
        }

        const transformedCoords = transformCoordinates(lineString.coordinates);

        // 버텍스 및 인덱스 생성
        const thickness = 0.05;
        const vertices = [];
        const indices = [];
        let accumulatedLength = 0;

        for (let i = 0; i < transformedCoords.length - 1; i++) {
            const a = transformedCoords[i];
            const b = transformedCoords[i + 1];
            const dx = b[0] - a[0];
            const dy = b[1] - a[1];
            const len = Math.hypot(dx, dy);
            if (len === 0) continue;

            const dirX = dx / len;
            const dirY = dy / len;
            const perpX = -dirY * thickness / 2;
            const perpY = dirX * thickness / 2;

            const aPlus = [a[0] + perpX, a[1] + perpY];
            const aMinus = [a[0] - perpX, a[1] - perpY];
            const bPlus = [b[0] + perpX, b[1] + perpY];
            const bMinus = [b[0] - perpX, b[1] - perpY];

            const startIndex = i * 4;
            vertices.push(
                ...aPlus, accumulatedLength,
                ...aMinus, accumulatedLength,
                ...bPlus, accumulatedLength + len,
                ...bMinus, accumulatedLength + len
            );

            indices.push(
                startIndex, startIndex + 1, startIndex + 2,
                startIndex + 1, startIndex + 3, startIndex + 2
            );

            accumulatedLength += len;
        }

        // 셰이더 소스
        const vsSource = `
            attribute vec2 position;
            attribute float distance;
            varying float vDistance;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
                vDistance = distance;
            }
        `;

        const fsSource = `
            precision mediump float;
            varying float vDistance;
            void main() {
                float dashLength = 0.2;
                float gapLength = 0.1;
                float total = dashLength + gapLength;
                float pos = mod(vDistance, total);
                if (pos > dashLength) discard;
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        `;

        // 셰이더 및 프로그램 설정
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vsSource);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fsSource);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // 버퍼 설정
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // 속성 설정
        const positionLocation = gl.getAttribLocation(program, 'position');
        const distanceLocation = gl.getAttribLocation(program, 'distance');

        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 12, 0);
        
        gl.enableVertexAttribArray(distanceLocation);
        gl.vertexAttribPointer(distanceLocation, 1, gl.FLOAT, false, 12, 8);

        // 렌더링
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    </script>
</body>
</html>
