<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL Linestring Test</title>
  <style>
    canvas { border: 1px solid black; }
  </style>
</head>
<body>
  <canvas id="glCanvas" width="800" height="600"></canvas>
  <script>
    // WebGL 셰이더 코드
    const vertexShaderSource = `
      #ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      #else
      precision mediump float;
      #endif

      uniform mat4 u_projectionMatrix;
      uniform mat4 u_screenToWorldMatrix;
      uniform vec2 u_viewportSizePx;
      uniform float u_pixelRatio;
      uniform float u_globalAlpha;
      uniform float u_time;
      uniform float u_zoom;
      uniform float u_resolution;
      uniform float u_rotation;
      uniform vec4 u_renderExtent;
      uniform vec2 u_patternOrigin;
      uniform float u_depth;
      uniform mediump int u_hitDetection;

      attribute vec2 a_position;
      attribute vec2 a_segmentStart;
      attribute vec2 a_segmentEnd;
      attribute float a_measureStart;
      attribute float a_measureEnd;
      attribute float a_distance;
      attribute vec4 a_hitColor;
      attribute float a_prop_layer;

      varying vec2 v_segmentStart;
      varying vec2 v_segmentEnd;
      varying vec4 v_hitColor;
      varying float v_distanceOffsetPx;
      varying float v_measureStart;
      varying float v_measureEnd;
      varying float v_prop_layer;

      vec2 worldToPx(vec2 worldPos) {
        vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
        return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
      }

      void main(void) {
        gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
        v_segmentStart = worldToPx(a_segmentStart);
        v_segmentEnd = worldToPx(a_segmentEnd);
        v_hitColor = a_hitColor;
        v_distanceOffsetPx = a_distance / u_resolution;
        v_measureStart = a_measureStart;
        v_measureEnd = a_measureEnd;
        v_prop_layer = a_prop_layer;
      }
    `;

    const fragmentShaderSource = `
      #ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      #else
      precision mediump float;
      #endif

      uniform mat4 u_projectionMatrix;
      uniform mat4 u_screenToWorldMatrix;
      uniform vec2 u_viewportSizePx;
      uniform float u_pixelRatio;
      uniform float u_globalAlpha;
      uniform float u_time;
      uniform float u_zoom;
      uniform float u_resolution;
      uniform float u_rotation;
      uniform vec4 u_renderExtent;
      uniform vec2 u_patternOrigin;
      uniform float u_depth;
      uniform mediump int u_hitDetection;

      uniform vec2 u_texture1269122425_size;
      uniform sampler2D u_texture1269122425;
      uniform sampler2D u_depthMask;
      uniform float u_tileZoomLevel;

      varying vec2 v_segmentStart;
      varying vec2 v_segmentEnd;
      varying vec4 v_hitColor;
      varying float v_distanceOffsetPx;
      varying float v_measureStart;
      varying float v_measureEnd;
      varying float v_prop_layer;

      const float PI = 3.141592653589793238;

      vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float startOffsetPx, float currentLengthPx, float currentRadiusRatio) {
        float scaleFactor = sampleSize.y / 20.0;
        float currentLengthScaled = currentLengthPx * scaleFactor;
        float spacingScaled = spacingPx * scaleFactor;
        float uCoordPx = mod(currentLengthScaled + (sampleSize.x * 0.5 - startOffsetPx * scaleFactor), spacingScaled);
        uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);
        if (uCoordPx > sampleSize.x - 1.0) {
          return vec4(0.0);
        }
        float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;
        vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;
        return texture2D(texture, texCoord);
      }

      vec2 pxToWorld(vec2 pxPos) {
        vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
        return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
      }

      void main(void) {
        vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;

        float segmentLength = length(v_segmentEnd - v_segmentStart);
        vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;
        vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);
        vec2 startToPoint = currentPoint - v_segmentStart;
        float lengthToPoint = max(0., min(dot(segmentTangent, startToPoint), segmentLength));
        float currentLengthPx = lengthToPoint + v_distanceOffsetPx;
        float currentRadiusPx = abs(dot(segmentNormal, startToPoint));
        float currentRadiusRatio = currentRadiusPx / 10.0;

        vec4 color = sampleStrokePattern(
          u_texture1269122425,
          u_texture1269122425_size,
          vec2(0.),
          u_texture1269122425_size,
          40.0,
          20.0,
          currentLengthPx,
          currentRadiusRatio
        );

        gl_FragColor = color;
        gl_FragColor.a *= u_globalAlpha;
        gl_FragColor.rgb *= gl_FragColor.a;

        if (u_hitDetection > 0) {
          if (gl_FragColor.a < 0.1) { discard; }
          gl_FragColor = v_hitColor;
        }
      }
    `;

    // WebGL 초기화 및 렌더링 코드
    (function() {
      const canvas = document.getElementById('glCanvas');
      const gl = canvas.getContext('webgl');
      if (!gl) {
        alert('WebGL을 지원하지 않는 브라우저입니다.');
        return;
      }

      // 셰이더 컴파일 함수
      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader 컴파일 실패:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program 링크 실패:', gl.getProgramInfoLog(program));
        return;
      }
      gl.useProgram(program);

      // Vertex Buffer 생성
      const vertices = [];
      const indices = [];

      // 간단한 직선 데이터 (world 좌표)
      const p0 = [100, 100]; // 시작점
      const p1 = [700, 500]; // 끝점
      const tangent = [p1[0] - p0[0], p1[1] - p0[1]];
      const length = Math.sqrt(tangent[0] * tangent[0] + tangent[1] * tangent[1]);
      tangent[0] /= length;
      tangent[1] /= length;
      const normal = [-tangent[1], tangent[0]];
      const lineWidth = 20.0;

      // 4개의 vertex 좌표 계산
      const startLeft = [p0[0] - normal[0] * lineWidth / 2, p0[1] - normal[1] * lineWidth / 2];
      const startRight = [p0[0] + normal[0] * lineWidth / 2, p0[1] + normal[1] * lineWidth / 2];
      const endLeft = [p1[0] - normal[0] * lineWidth / 2, p1[1] - normal[1] * lineWidth / 2];
      const endRight = [p1[0] + normal[0] * lineWidth / 2, p1[1] + normal[1] * lineWidth / 2];

      // Attribute 데이터 (stride: 14 = a_position(2) + a_segmentStart(2) + a_segmentEnd(2) + a_measureStart(1) + a_measureEnd(1) + a_distance(1) + a_hitColor(4) + a_prop_layer(1))
      const hitColor = [1.0, 0.0, 0.0, 1.0]; // 빨간색
      const propLayer = 0.0;
      vertices.push(
        startLeft[0], startLeft[1], p0[0], p0[1], p1[0], p1[1], 0.0, length, 0.0, ...hitColor, propLayer,
        startRight[0], startRight[1], p0[0], p0[1], p1[0], p1[1], 0.0, length, 0.0, ...hitColor, propLayer,
        endLeft[0], endLeft[1], p0[0], p0[1], p1[0], p1[1], 0.0, length, 0.0, ...hitColor, propLayer,
        endRight[0], endRight[1], p0[0], p0[1], p1[0], p1[1], 0.0, length, 0.0, ...hitColor, propLayer
      );

      // Index Buffer (두 개의 삼각형)
      indices.push(0, 1, 2, 1, 2, 3);

      // Buffer 생성 및 데이터 업로드
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

      // Attribute 위치 설정
      const stride = 14 * 4; // 14 floats * 4 bytes
      const aPositionLoc = gl.getAttribLocation(program, 'a_position');
      gl.enableVertexAttribArray(aPositionLoc);
      gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, stride, 0);

      const aSegmentStartLoc = gl.getAttribLocation(program, 'a_segmentStart');
      gl.enableVertexAttribArray(aSegmentStartLoc);
      gl.vertexAttribPointer(aSegmentStartLoc, 2, gl.FLOAT, false, stride, 8);

      const aSegmentEndLoc = gl.getAttribLocation(program, 'a_segmentEnd');
      gl.enableVertexAttribArray(aSegmentEndLoc);
      gl.vertexAttribPointer(aSegmentEndLoc, 2, gl.FLOAT, false, stride, 16);

      const aMeasureStartLoc = gl.getAttribLocation(program, 'a_measureStart');
      gl.enableVertexAttribArray(aMeasureStartLoc);
      gl.vertexAttribPointer(aMeasureStartLoc, 1, gl.FLOAT, false, stride, 24);

      const aMeasureEndLoc = gl.getAttribLocation(program, 'a_measureEnd');
      gl.enableVertexAttribArray(aMeasureEndLoc);
      gl.vertexAttribPointer(aMeasureEndLoc, 1, gl.FLOAT, false, stride, 28);

      const aDistanceLoc = gl.getAttribLocation(program, 'a_distance');
      gl.enableVertexAttribArray(aDistanceLoc);
      gl.vertexAttribPointer(aDistanceLoc, 1, gl.FLOAT, false, stride, 32);

      const aHitColorLoc = gl.getAttribLocation(program, 'a_hitColor');
      gl.enableVertexAttribArray(aHitColorLoc);
      gl.vertexAttribPointer(aHitColorLoc, 4, gl.FLOAT, false, stride, 36);

      const aPropLayerLoc = gl.getAttribLocation(program, 'a_prop_layer');
      gl.enableVertexAttribArray(aPropLayerLoc);
      gl.vertexAttribPointer(aPropLayerLoc, 1, gl.FLOAT, false, stride, 52);

      // Uniform 설정
      const orthoMatrix = [
        2 / canvas.width, 0, 0, 0,
        0, -2 / canvas.height, 0, 0,
        0, 0, 1, 0,
        -1, 1, 0, 1
      ];
      gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_projectionMatrix'), false, orthoMatrix);
      gl.uniform2f(gl.getUniformLocation(program, 'u_viewportSizePx'), canvas.width, canvas.height);
      gl.uniform1f(gl.getUniformLocation(program, 'u_pixelRatio'), window.devicePixelRatio || 1);
      gl.uniform1f(gl.getUniformLocation(program, 'u_globalAlpha'), 1.0);
      gl.uniform1f(gl.getUniformLocation(program, 'u_resolution'), 1.0);
      gl.uniform1i(gl.getUniformLocation(program, 'u_hitDetection'), 0);

      // 텍스처 생성 (단순한 단색 텍스처로 대체)
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 0, 255]));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.uniform2f(gl.getUniformLocation(program, 'u_texture1269122425_size'), 1, 1);
      gl.uniform1i(gl.getUniformLocation(program, 'u_texture1269122425'), 0);

      // 렌더링
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    })();
  </script>
</body>
</html>
