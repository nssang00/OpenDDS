<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL LineString Rendering</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #222; }
        canvas { border: 1px solid white; }
    </style>
</head>
<body>
    <canvas id="glCanvas" width="800" height="600"></canvas>
    <script>
        // WebGL 초기화
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl");
        if (!gl) {
            alert("WebGL을 지원하지 않는 브라우저입니다.");
            throw new Error("WebGL을 지원하지 않습니다.");
        }

        // 정점 셰이더 (좌표 변환 및 투영)
        const vsSource = `
            attribute vec3 a_position;
            uniform mat4 u_modelMatrix;
            uniform mat4 u_viewMatrix;
            uniform mat4 u_projectionMatrix;

            vec3 transformPosition(vec3 position, mat4 modelMatrix) {
                return (modelMatrix * vec4(position, 1.0)).xyz;
            }

            void main() {
                vec3 worldPosition = transformPosition(a_position, u_modelMatrix);
                gl_Position = u_projectionMatrix * u_viewMatrix * vec4(worldPosition, 1.0);
            }
        `;

        // 프래그먼트 셰이더 (라인 색상 설정)
        const fsSource = `
            precision mediump float;
            uniform vec4 u_color;
            void main() {
                gl_FragColor = u_color;
            }
        `;

        // 셰이더 컴파일 함수
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        // WebGL 프로그램 생성
        const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // ✅ 여러 개의 LineString 데이터
        const lineVertices = new Float32Array([
            -0.5,  0.0,  0.0,  0.0,  0.5,  0.0,  0.5,  0.0,  0.0,  // 첫 번째 LineString
            -0.7, -0.2,  0.0, -0.2, -0.5,  0.0,  0.3, -0.2,  0.0   // 두 번째 LineString
        ]);

        // 인덱스 데이터 (각 LineString의 연결 순서)
        const lineIndices = new Uint16Array([
            0, 1, 2,   // 첫 번째 LineString
            3, 4, 5    // 두 번째 LineString
        ]);

        // 정점 버퍼 생성 및 데이터 설정
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, lineVertices, gl.STATIC_DRAW);

        // 인덱스 버퍼 생성 및 데이터 설정
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, lineIndices, gl.STATIC_DRAW);

        // 위치 속성 가져오기 및 설정
        const positionLocation = gl.getAttribLocation(program, "a_position");
        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLocation);

        // 행렬 설정
        const modelMatrix = mat4.create();
        const viewMatrix = mat4.create();
        const projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 10.0);
        mat4.translate(viewMatrix, viewMatrix, [0, 0, -2]);

        // 행렬 유니폼 위치 가져오기
        const modelMatrixLocation = gl.getUniformLocation(program, "u_modelMatrix");
        const viewMatrixLocation = gl.getUniformLocation(program, "u_viewMatrix");
        const projectionMatrixLocation = gl.getUniformLocation(program, "u_projectionMatrix");

        // 행렬 유니폼 값 설정
        gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);
        gl.uniformMatrix4fv(viewMatrixLocation, false, viewMatrix);
        gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);

        // 선 색상 설정
        const colorLocation = gl.getUniformLocation(program, "u_color");
        gl.uniform4f(colorLocation, 1.0, 0.0, 0.0, 1.0); // 빨간색

        // WebGL 설정
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.lineWidth(2.0);

        // 렌더링 함수
        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // 여러 개의 LineString 그리기
            gl.drawElements(gl.LINES, lineIndices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }

        render();
    </script>
    <!-- WebGL을 위한 glMatrix 라이브러리 (행렬 연산) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
</body>
</html>
