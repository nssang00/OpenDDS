<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGL Instancing Line Rendering</title>
  <style>
    canvas { border: 1px solid black; }
  </style>
</head>
<body>
  <canvas id="canvas" width="800" height="600"></canvas>
  <script>
    // WebGL 컨텍스트 설정
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
      alert('WebGL을 지원하지 않는 브라우저입니다.');
      throw new Error('WebGL not supported');
    }

    // Instancing 확장 활성화 (WebGL 1.0)
    const ext = gl.getExtension('ANGLE_instanced_arrays');
    if (!ext && !gl.drawArraysInstanced) {
      alert('Instancing을 지원하지 않습니다.');
      throw new Error('Instancing not supported');
    }
    const drawElementsInstanced = ext ? ext.drawElementsInstancedANGLE.bind(ext) : gl.drawElementsInstanced.bind(gl);
    const vertexAttribDivisor = ext ? ext.vertexAttribDivisorANGLE.bind(ext) : gl.vertexAttribDivisor.bind(gl);

    // 셰이더 소스
    const vertexShaderSource = `
      #ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      #else
      precision mediump float;
      #endif

      attribute vec2 a_position;
      attribute vec2 a_segmentStart;
      attribute vec2 a_segmentEnd;
      attribute float a_lineWidth;
      attribute vec4 a_hitColor;

      uniform mat4 u_projectionMatrix;
      uniform vec2 u_viewportSizePx;

      varying vec2 v_segmentStartPx;
      varying vec2 v_segmentEndPx;
      varying vec4 v_hitColor;

      vec2 worldToPx(vec2 worldPos) {
        vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
        return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
      }

      void main() {
        vec2 segmentStartPx = worldToPx(a_segmentStart);
        vec2 segmentEndPx = worldToPx(a_segmentEnd);
        vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
        vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);

        vec2 basePos = mix(segmentStartPx, segmentEndPx, a_position.x * 0.5 + 0.5);
        vec2 positionPx = basePos + normalPx * a_lineWidth * a_position.y;

        gl_Position = vec4(2.0 * positionPx / u_viewportSizePx - 1.0, 0.0, 1.0);
        v_segmentStartPx = segmentStartPx;
        v_segmentEndPx = segmentEndPx;
        v_hitColor = a_hitColor;
      }
    `;

    const fragmentShaderSource = `
      #ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      #else
      precision mediump float;
      #endif

      uniform float u_globalAlpha;
      uniform vec2 u_dashParams; // [dashLength, dashGap]

      varying vec2 v_segmentStartPx;
      varying vec2 v_segmentEndPx;
      varying vec4 v_hitColor;

      void main() {
        vec2 pxPos = gl_FragCoord.xy;
        float lineMetric = length(pxPos - v_segmentStartPx) / length(v_segmentEndPx - v_segmentStartPx);
        if (mod(lineMetric * u_dashParams.x, 1.0) > u_dashParams.y) discard;

        gl_FragColor = v_hitColor;
        gl_FragColor.a *= u_globalAlpha;
        gl_FragColor.rgb *= gl_FragColor.a;
      }
    `;

    // 셰이더 컴파일 함수
    function compileShader(source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    // 프로그램 생성
    const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);

    // Attribute 및 Uniform 위치
    const loc_a_position = gl.getAttribLocation(program, 'a_position');
    const loc_a_segmentStart = gl.getAttribLocation(program, 'a_segmentStart');
    const loc_a_segmentEnd = gl.getAttribLocation(program, 'a_segmentEnd');
    const loc_a_lineWidth = gl.getAttribLocation(program, 'a_lineWidth');
    const loc_a_hitColor = gl.getAttribLocation(program, 'a_hitColor');
    const loc_u_projectionMatrix = gl.getUniformLocation(program, 'u_projectionMatrix');
    const loc_u_viewportSizePx = gl.getUniformLocation(program, 'u_viewportSizePx');
    const loc_u_globalAlpha = gl.getUniformLocation(program, 'u_globalAlpha');
    const loc_u_dashParams = gl.getUniformLocation(program, 'u_dashParams');

    // Vertex Buffer (기본 사각형)
    const vertices = new Float32Array([
      -1.0, -1.0, // 좌하
      -1.0,  1.0, // 좌상
       1.0, -1.0, // 우하
       1.0,  1.0, // 우상
    ]);
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    // Instance Buffer (선분 데이터)
    const instanceData = new Float32Array([
      // 선분 1: segmentStart, segmentEnd, lineWidth, hitColor
      100.0, 100.0, 300.0, 100.0, 10.0, 1.0, 0.0, 0.0, 1.0,
      // 선분 2
      200.0, 200.0, 400.0, 300.0, 15.0, 0.0, 1.0, 0.0, 1.0,
      // 선분 3
      500.0, 400.0, 600.0, 500.0, 20.0, 0.0, 0.0, 1.0, 1.0,
    ]);
    const instanceCount = 3; // 선분 수
    const instanceBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, instanceData, gl.DYNAMIC_DRAW);

    // Index Buffer
    const indices = new Uint16Array([0, 1, 2, 1, 2, 3]);
    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    // Attribute 설정
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(loc_a_position, 2, gl.FLOAT, false, 8, 0);
    gl.enableVertexAttribArray(loc_a_position);

    gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
    let offset = 0;
    gl.vertexAttribPointer(loc_a_segmentStart, 2, gl.FLOAT, false, 36, offset); offset += 8;
    gl.vertexAttribPointer(loc_a_segmentEnd, 2, gl.FLOAT, false, 36, offset); offset += 8;
    gl.vertexAttribPointer(loc_a_lineWidth, 1, gl.FLOAT, false, 36, offset); offset += 4;
    gl.vertexAttribPointer(loc_a_hitColor, 4, gl.FLOAT, false, 36, offset);
    gl.enableVertexAttribArray(loc_a_segmentStart);
    gl.enableVertexAttribArray(loc_a_segmentEnd);
    gl.enableVertexAttribArray(loc_a_lineWidth);
    gl.enableVertexAttribArray(loc_a_hitColor);

    // Instancing 설정
    vertexAttribDivisor(loc_a_segmentStart, 1);
    vertexAttribDivisor(loc_a_segmentEnd, 1);
    vertexAttribDivisor(loc_a_lineWidth, 1);
    vertexAttribDivisor(loc_a_hitColor, 1);

    // Uniform 설정
    const projectionMatrix = [
      2 / canvas.width, 0, 0, -1,
      0, -2 / canvas.height, 0, 1,
      0, 0, 1, 0,
      0, 0, 0, 1
    ];
    gl.uniformMatrix4fv(loc_u_projectionMatrix, false, projectionMatrix);
    gl.uniform2f(loc_u_viewportSizePx, canvas.width, canvas.height);
    gl.uniform1f(loc_u_globalAlpha, 1.0);
    gl.uniform2f(loc_u_dashParams, 20.0, 0.5); // 대시 길이, 간격 비율

    // 렌더링
    gl.clearColor(1.0, 1.0, 1.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, instanceCount);
  </script>
</body>
</html>코드 설명1. HTML 구조<canvas> 요소를 사용하여 WebGL 렌더링 영역을 정의합니다.2. WebGL 설정WebGL 1.0과 2.0을 모두 지원하도록 컨텍스트를 가져오고, instancing 확장을 활성화합니다.3. 셰이더Vertex Shader: 기본 사각형(a_position)과 인스턴스 데이터(a_segmentStart, a_segmentEnd, a_lineWidth, a_hitColor)를 사용해 선분 위치를 계산.Fragment Shader: 대시 패턴을 적용하고, 색상을 설정.4. 버퍼Vertex Buffer: 단일 사각형(4 vertex, 32 bytes).Instance Buffer: 선분 3개 예시(각 36 bytes, 총 108 bytes).각 인스턴스: segmentStart (8), segmentEnd (8), lineWidth (4), hitColor (16).Index Buffer: 2 삼각형(12 bytes).5. 렌더링gl.drawElementsInstanced를 사용해 3개의 선분을 그림.선분은 각각 다른 두께와 색상으로 표시되며, 대시 패턴이 적용됩니다.실행 결과캔버스에 3개의 선분이 그려집니다:(100, 100)에서 (300, 100)까지, 두께 10, 빨간색.(200, 200)에서 (400, 300)까지, 두께 15, 초록색.(500, 400)에서 (600, 500)까지, 두께 20, 파란색.모든 선분에 대시 패턴(길이 20px, 간격 50%)이 적용됩니다.확장 방법텍스처 추가: u_texture uniform과 UV 계산을 프래그먼트 셰이더에 추가.동적 업데이트: instanceBuffer에 새로운 데이터를 gl.bufferSubData로 업데이트.조인 개선: a_joinAngles를 인스턴스 데이터에 추가해 조인 로직 복원.테스트해보시고 추가 질문이나 수정할 부분이 있으면 말씀해주세요!
