<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>LineString instanced-quad test</title>
<style>
  body,html{margin:0;height:100%;background:#111;color:#ccc;font:13px/1.4 sans-serif}
  #glcanvas{display:block;width:100%;height:100%;}
</style>
</head>
<body>
<canvas id="glcanvas" width="800" height="600"></canvas>

<!-- ====================================================================
File: src/ol/render/webgl/linestringreplay/defaultshader/linestring.vert
(GLSL 1.00 – WebGL 1/2 호환, a_vertexNumber 정적 VBO 방식)
==================================================================== -->
<script id="line-vert" type="x-shader/x-vertex">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

attribute float a_vertexNumber;           // 정적 코너 VBO 0,1,2,3
attribute vec2  a_segmentStart;
attribute vec2  a_segmentEnd;
attribute float a_measureStart;
attribute float a_measureEnd;
attribute float a_angleStart;
attribute float a_angleEnd;
attribute float a_angleTangentSum;
attribute float a_distance;
attribute vec4  a_hitColor;
attribute float a_prop_layer;
/* custom attribute 자리 */

uniform mat4  u_projectionMatrix;
uniform vec2  u_viewportSizePx;
uniform float u_resolution;
uniform float u_depth;

varying vec2  v_segmentStart;
varying vec2  v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4  v_hitColor;
varying float v_distanceOffsetPx;
varying float v_measureStart;
varying float v_measureEnd;
varying float v_prop_layer;

vec2 worldToPx(vec2 w){vec4 s=u_projectionMatrix*vec4(w,0.,1.);return(.5*s.xy+.5)*u_viewportSizePx;}
vec4 pxToScreen(vec2 p){vec2 s=2.*p/u_viewportSizePx-1.;return vec4(s,u_depth,1.);}
bool isCap(float a){return a<-0.1;}
vec2 joinDir(vec2 n,float a){float h=a*.5,c=cos(h),s=sin(h);return vec2(s*n.x+c*n.y,-c*n.x+s*n.y)*(1./s);}
vec2 offsetPt(vec2 pt,vec2 n,float a,float off){return (cos(a)>0.998||isCap(a))?pt-n*off:pt-joinDir(n,a)*off;}

void main(void){
    float vertexNumber = a_vertexNumber;

    v_angleStart = a_angleStart;
    v_angleEnd   = a_angleEnd;

    float lineWidth   = 20.0;
    float lineOffsetPx = 0.0;

    vec2 p0 = worldToPx(a_segmentStart);
    vec2 p1 = worldToPx(a_segmentEnd);
    vec2 tg = normalize(p1 - p0);
    vec2 n  = vec2(-tg.y, tg.x);

    p0 = offsetPt(p0,n,v_angleStart,lineOffsetPx);
    p1 = offsetPt(p1,n,v_angleEnd  ,lineOffsetPx);

    float nDir = (vertexNumber==0.0 || vertexNumber==3.0)? 1.0 : -1.0;
    float tDir = (vertexNumber<2.0)? 1.0 : -1.0;
    float ang  = (vertexNumber<2.0)? v_angleStart : v_angleEnd;
    vec2  join = (cos(ang)>0.985||isCap(ang)) ? n*nDir - tg*tDir
                                              : joinDir(n*nDir,ang);

    vec2 posPx = ((vertexNumber<2.0)? p0 : p1) + join*(lineWidth*0.5 + 1.0);
    gl_Position = pxToScreen(posPx);

    v_segmentStart      = p0;
    v_segmentEnd        = p1;
    v_width             = lineWidth;
    v_hitColor          = a_hitColor;
    v_distanceOffsetPx  = a_distance/u_resolution - (lineOffsetPx * a_angleTangentSum);
    v_measureStart      = a_measureStart;
    v_measureEnd        = a_measureEnd;
    v_prop_layer        = a_prop_layer;
}
</script>

<!-- ====================================================================
File: src/ol/render/webgl/linestringreplay/defaultshader/linestring.frag
==================================================================== -->
<script id="line-frag" type="x-shader/x-fragment">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

varying vec4 v_hitColor;
void main(void){
    gl_FragColor = v_hitColor;
}
</script>

<!-- ====================================================================
File: src/ol/render/webgl/linestringreplay/demo.js
(정적 VBO/VAO/인스턴스 버퍼 구성 및 draw)
==================================================================== -->
<script type="text/javascript">
(function(){

// ---- WebGL 컨텍스트 얻기
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
if(!gl){ alert('WebGL unavailable'); return; }
const isWebGL2 = (gl instanceof WebGL2RenderingContext);
const extInst = isWebGL2 ? null : gl.getExtension('ANGLE_instanced_arrays');
if(!isWebGL2 && !extInst){
  alert('ANGLE_instanced_arrays not supported');
  return;
}

// ---- 유틸
function compileShader(src,id,type){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, document.getElementById(id).textContent);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
    console.error('shader error', gl.getShaderInfoLog(sh));
  }
  return sh;
}
function linkProgram(vId,fId){
  const prog = gl.createProgram();
  gl.attachShader(prog, compileShader(0,vId,gl.VERTEX_SHADER));
  gl.attachShader(prog, compileShader(0,fId,gl.FRAGMENT_SHADER));
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    console.error('link err', gl.getProgramInfoLog(prog));
  }
  return prog;
}

// ---- 프로그램 & 유니폼
const program = linkProgram('line-vert','line-frag');
gl.useProgram(program);

const uProj  = gl.getUniformLocation(program,'u_projectionMatrix');
const uView  = gl.getUniformLocation(program,'u_viewportSizePx');
const uRes   = gl.getUniformLocation(program,'u_resolution');
const uDepth = gl.getUniformLocation(program,'u_depth');

// 간단한 단위 행렬 (world == clip)
gl.uniformMatrix4fv(uProj,false,new Float32Array([
  1,0,0,0,
  0,1,0,0,
  0,0,1,0,
  0,0,0,1
]));
gl.uniform2f(uView, canvas.width, canvas.height);
gl.uniform1f(uRes, 1.0);
gl.uniform1f(uDepth, 0.0);

// ====================================================================
// 1) 정적 VBO & 인덱스 VBO (코너 0-1-2-3  ▶  0-1-2,0-2-3)
// ====================================================================
const quadVbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadVbo);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,1,2,3]), gl.STATIC_DRAW);

const idxVbo = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxVbo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
              new Uint16Array([0,1,2, 0,2,3]), gl.STATIC_DRAW);

// ====================================================================
// 2) 인스턴스 데이터 작성 (세그먼트 2개만 예시)
//    attribute layout 순서:
//    start(2) end(2) m0 m1 ang0 ang1 tanSum dist color(4) layer
//    = 15 floats (60byte) stride
// ====================================================================
const SEG_STRIDE_FLOAT = 15;
const instanceData = new Float32Array([
  // ─ segment 0 : red,  (-0.8,-0.8) → (0.8,-0.2)
  -0.8, -0.8,  0.8, -0.2,   // a_segmentStart, a_segmentEnd
   0.0,  0.0,              // measure
  -1.0, -1.0,              // angleStart/End (cap)
   0.0,                    // angleTangentSum
   0.0,                    // distance
   1.0, 0.0, 0.0, 1.0,     // hitColor
   0.0,                    // prop_layer
  // ─ segment 1 : blue, (-0.8, 0.8) → (0.8, 0.2)
  -0.8,  0.8,  0.8,  0.2,
   0.0,  0.0,
  -1.0, -1.0,
   0.0,
   0.0,
   0.0, 0.0, 1.0, 1.0,
   0.0
]);
const instVbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, instVbo);
gl.bufferData(gl.ARRAY_BUFFER, instanceData, gl.STATIC_DRAW);

// ====================================================================
// 3) VAO 구성
// ====================================================================
const strideBytes = SEG_STRIDE_FLOAT * 4;
const locVertexNum = gl.getAttribLocation(program,'a_vertexNumber');
gl.bindBuffer(gl.ARRAY_BUFFER, quadVbo);
gl.vertexAttribPointer(locVertexNum,1,gl.FLOAT,false,0,0);
gl.enableVertexAttribArray(locVertexNum);            // divisor 0 (코너)

function enableInst(attr,size,type,offset){
  if(attr<0) return;
  gl.vertexAttribPointer(attr,size,type,false,strideBytes,offset);
  gl.enableVertexAttribArray(attr);
  if(isWebGL2){ gl.vertexAttribDivisor(attr,1); }
  else        { extInst.vertexAttribDivisorANGLE(attr,1); }
}
let offs = 0;
enableInst(gl.getAttribLocation(program,'a_segmentStart'),2,gl.FLOAT,offs); offs+=8;
enableInst(gl.getAttribLocation(program,'a_segmentEnd'),  2,gl.FLOAT,offs); offs+=8;
enableInst(gl.getAttribLocation(program,'a_measureStart'),1,gl.FLOAT,offs); offs+=4;
enableInst(gl.getAttribLocation(program,'a_measureEnd'), 1,gl.FLOAT,offs); offs+=4;
enableInst(gl.getAttribLocation(program,'a_angleStart'), 1,gl.FLOAT,offs); offs+=4;
enableInst(gl.getAttribLocation(program,'a_angleEnd'),   1,gl.FLOAT,offs); offs+=4;
enableInst(gl.getAttribLocation(program,'a_angleTangentSum'),1,gl.FLOAT,offs); offs+=4;
enableInst(gl.getAttribLocation(program,'a_distance'),1,gl.FLOAT,offs); offs+=4;
enableInst(gl.getAttribLocation(program,'a_hitColor'),4,gl.FLOAT,offs); offs+=16;
enableInst(gl.getAttribLocation(program,'a_prop_layer'),1,gl.FLOAT,offs);

// index VBO
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxVbo);

// ====================================================================
// 4) draw
// ====================================================================
gl.clearColor(0.07,0.07,0.07,1);
gl.clear(gl.COLOR_BUFFER_BIT);

const segCount = 2;
if(isWebGL2){
  gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, segCount);
}else{
  extInst.drawElementsInstancedANGLE(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, segCount);
}

})();
</script>
</body>
</html>
