<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>Instanced Quad LineString Demo</title>
<style>html,body{height:100%;margin:0;background:#101012}canvas{display:block;width:100%;height:100%}</style>
</head>
<body>
<canvas id="glc" width="960" height="640"></canvas>

<!-- ──────────────────────── VERTEX ──────────────────────── -->
<script id="sh-v" type="x-shader/x-vertex">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

attribute float a_vertexNumber;   // 0‒3 (static corner VBO)

attribute vec2  a_segmentStart;   // 인스턴스 VBO
attribute vec2  a_segmentEnd;
attribute vec4  a_hitColor;

uniform mat4  u_proj;             // 픽셀→clip 변환
uniform float u_lineWidth;

varying vec4 v_color;

vec4 pxToClip(vec2 p){                // 픽셀 → clip
  vec2 s = 2.0 * p / u_proj[0].xy - 1.0;
  return vec4(s, 0.0, 1.0);
}

void main(){
  /* ① 월드→픽셀 (데모에선 world == pixel) */
  vec2 p0 = a_segmentStart;
  vec2 p1 = a_segmentEnd;

  /* ② 방향 벡터 계산 */
  vec2 t  = normalize(p1-p0);          // tangent
  vec2 n  = vec2(-t.y, t.x);           // normal

  /* ③ a_vertexNumber 로 코너 선택 */
  bool head = (a_vertexNumber < 2.0);  // 0,1 은 p0 쪽
  float side = (mod(a_vertexNumber,2.0)<0.5) ? +1.0 : -1.0;

  vec2 base = head ? p0 : p1;
  vec2 posPX = base + n * side * (u_lineWidth*0.5);

  gl_Position = pxToClip( posPX );
  v_color = a_hitColor;
}
</script>

<!-- ──────────────────────── FRAGMENT ──────────────────────── -->
<script id="sh-f" type="x-shader/x-fragment">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
varying vec4 v_color;
void main(){ gl_FragColor = v_color; }
</script>

<!-- ──────────────────────── JS ──────────────────────── -->
<script>
(() => {
  /* ── 컨텍스트 취득 ─────────────────────────────── */
  const cvs = document.getElementById('glc');
  const gl  = cvs.getContext('webgl2') || cvs.getContext('webgl');
  if(!gl){ alert('WebGL 지원 안됨'); return; }

  const isGL2 = (gl instanceof WebGL2RenderingContext);
  const inst  = isGL2 ? null : gl.getExtension('ANGLE_instanced_arrays');
  if(!isGL2 && !inst){ alert('ANGLE_instanced_arrays 없음'); return; }

  /* ── 셰이더 컴파일 & 프로그램 ──────────────────── */
  function compile(id, type){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, document.getElementById(id).textContent);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS))
      console.error(id, gl.getShaderInfoLog(sh));
    return sh;
  }
  const prog = gl.createProgram();
  gl.attachShader(prog, compile('sh-v', gl.VERTEX_SHADER));
  gl.attachShader(prog, compile('sh-f', gl.FRAGMENT_SHADER));
  gl.linkProgram(prog);
  gl.useProgram(prog);

  /* ── 정적 코너 VBO + 인덱스 VBO ───────────────── */
  const vboCorner = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboCorner);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,1,2,3]), gl.STATIC_DRAW);

  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2, 0,2,3]), gl.STATIC_DRAW);

  /* ── 인스턴스 VBO (start.xy, end.xy, color.rgba) ─ */
  const stride = 8 + 8 + 16;          // 32 bytes
  const instData = new Float32Array([
    // x0  y0   x1  y1    r  g  b  a
    100,100, 860,220,   1,0,0,1,     // 빨강
    100,540, 860,420,   0,0.4,1,1    // 파랑
  ]);
  const vboInst = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboInst);
  gl.bufferData(gl.ARRAY_BUFFER, instData, gl.STATIC_DRAW);

  /* ── attribute 바인딩 ─────────────────────────── */
  const locCorner = gl.getAttribLocation(prog,'a_vertexNumber');
  gl.bindBuffer(gl.ARRAY_BUFFER, vboCorner);
  gl.vertexAttribPointer(locCorner,1,gl.FLOAT,false,0,0);
  gl.enableVertexAttribArray(locCorner);

  function instAttrib(name, size, type, byteOffset){
    const loc = gl.getAttribLocation(prog,name);
    if(loc<0) return;
    gl.bindBuffer(gl.ARRAY_BUFFER, vboInst);
    gl.vertexAttribPointer(loc,size,type,false,stride,byteOffset);
    gl.enableVertexAttribArray(loc);
    if(isGL2) gl.vertexAttribDivisor(loc,1);
    else      inst.vertexAttribDivisorANGLE(loc,1);
  }
  instAttrib('a_segmentStart',2,gl.FLOAT, 0);
  instAttrib('a_segmentEnd',  2,gl.FLOAT, 8);
  instAttrib('a_hitColor',    4,gl.FLOAT,16);

  /* ── uniform & 상태 값 ─────────────────────────── */
  const uProj = gl.getUniformLocation(prog,'u_proj');
  const uLW   = gl.getUniformLocation(prog,'u_lineWidth');

  /*  viewport 행렬: (w,h)를 mat4 의 1~2열에 저장해 픽셀→clip 변환용 */
  gl.uniformMatrix4fv(uProj,false,new Float32Array([
    cvs.width , cvs.height, 0,0,
    0,0,0,0,
    0,0,0,0,
    0,0,0,1
  ]));
  gl.uniform1f(uLW, 40.0);

  /* 필수 상태 */
  gl.viewport(0,0,cvs.width,cvs.height);
  gl.clearColor(0.05,0.05,0.06,1);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  /* ── 렌더링 ─────────────────────────────────────── */
  gl.clear(gl.COLOR_BUFFER_BIT);
  const segCount = 2;
  if(isGL2)
    gl.drawElementsInstanced(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0,segCount);
  else
    inst.drawElementsInstancedANGLE(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0,segCount);
})();
</script>
</body>
</html>
