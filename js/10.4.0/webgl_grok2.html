<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL GIS LineString Rendering (Fixed)</title>
    <style>
        canvas { border: 1px solid black; }
    </style>
</head>
<body>
    <canvas id="canvas" width="400" height="400"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL이 지원되지 않습니다.');
            throw new Error('WebGL not supported');
        }

        // Shader 코드 (변경 없음)
        const vertexShaderSource = `
        attribute vec2 a_position;
        uniform vec3 u_color;
        varying vec3 v_color;

        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_color = u_color;
        }
        `;

        const fragmentShaderSource = `
        precision mediump float;
        varying vec3 v_color;

        void main() {
            gl_FragColor = vec4(v_color, 1.0);
        }
        `;

        // Shader 및 프로그램 생성 함수 (변경 없음)
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // 벡터 정규화 함수 추가
        function normalize(v) {
            const length = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
            return length > 0 ? [v[0]/length, v[1]/length] : [0, 0];
        }

        // 개선된 법선 계산 함수
        function calculateNormalsAndVertices(points, thickness) {
            const vertices = [];
            const indices = [];
            const normals = [];

            for (let i = 0; i < points.length; i++) {
                const prev = points[Math.max(0, i - 1)];
                const curr = points[i];
                const next = points[Math.min(points.length - 1, i + 1)];

                // 방향 벡터 계산
                const dirPrev = [curr[0] - prev[0], curr[1] - prev[1]];
                const dirNext = [next[0] - curr[0], next[1] - curr[1]];

                // 수직 벡터 계산
                const normalPrev = normalize([dirPrev[1], -dirPrev[0]]);
                const normalNext = normalize([dirNext[1], -dirNext[0]]);

                // 조인 처리 (Miter)
                let normal;
                if(i === 0) { // 첫 번째 점
                    normal = normalNext;
                } else if(i === points.length-1) { // 마지막 점
                    normal = normalPrev;
                } else { // 중간 점
                    const tangent = normalize([
                        normalPrev[0] + normalNext[0],
                        normalPrev[1] + normalNext[1]
                    ]);
                    const miterLength = 1 / Math.max(Math.sqrt(
                        tangent[0]*tangent[0] + tangent[1]*tangent[1]
                    ), 0.001);
                    normal = [tangent[0] * miterLength, tangent[1] * miterLength];
                }

                normals.push([
                    normal[0] * thickness,
                    normal[1] * thickness
                ]);
            }

            // 정점 생성
            for (let i = 0; i < points.length; i++) {
                const [x, y] = points[i];
                const [nx, ny] = normals[i];
                vertices.push(
                    x - nx, y - ny, // 왼쪽 정점
                    x + nx, y + ny  // 오른쪽 정점
                );
            }

            // 인덱스 생성
            for (let i = 0; i < points.length - 1; i++) {
                const base = i * 2;
                indices.push(
                    base, base+1, base+2,
                    base+1, base+3, base+2
                );
            }

            return {
                vertices: new Float32Array(vertices),
                indices: new Uint16Array(indices)
            };
        }

        // 좌표 정규화 함수 (변경 없음)
        function normalizeCoordinates(coords, canvasWidth, canvasHeight) {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            coords.forEach(([x, y]) => {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                max
