<!DOCTYPE html><html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Thick LineString with Miter Joints</title>
    <style>
        canvas { border: 1px solid black; }
    </style>
</head>
<body>
    <canvas id="canvas" width="400" height="400"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL이 지원되지 않습니다.');
            throw new Error('WebGL not supported');
        }const vertexShaderSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform float u_thickness;
    uniform vec3 u_color;
    varying vec3 v_color;

    void main() {
        vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        v_color = u_color;
    }
    `;

    const fragmentShaderSource = `
    precision mediump float;
    varying vec3 v_color;
    
    void main() {
        gl_FragColor = vec4(v_color, 1.0);
    }
    `;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);

    const paths = [[10, 75], [90, 100], [130, 50], [150, 100], [160, 50], [170, 100], [180, 50]];
    const thickness = 5.0;
    const color = [1.0, 0.0, 0.0]; // 빨간색

    function normalizePath(paths, width, height) {
        return paths.flat().map(([x, y]) => [x, height - y]);
    }

    const normalizedPaths = normalizePath(paths, canvas.width, canvas.height).flat();
    const vertices = new Float32Array(normalizedPaths);

    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
    const thicknessLocation = gl.getUniformLocation(program, 'u_thickness');
    const colorLocation = gl.getUniformLocation(program, 'u_color');

    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);

    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
    gl.uniform1f(thicknessLocation, thickness);
    gl.uniform3fv(colorLocation, color);

    gl.drawArrays(gl.LINE_STRIP, 0, paths.length);
</script>

</body>
</html>
