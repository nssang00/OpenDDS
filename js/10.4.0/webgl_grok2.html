<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Thick LineString with Uniform Thickness</title>
    <style>
        canvas { border: 1px solid black; }
    </style>
</head>
<body>
    <canvas id="canvas" width="400" height="400"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL이 지원되지 않습니다.');
            throw new Error('WebGL not supported');
        }

        const vertexShaderSource = `
        attribute vec2 a_position;
        uniform vec3 u_color;
        varying vec3 v_color;

        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_color = u_color;
        }
        `;

        const fragmentShaderSource = `
        precision mediump float;
        varying vec3 v_color;

        void main() {
            gl_FragColor = vec4(v_color, 1.0);
        }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const paths = [[[10,75], [90,100], [130,50], [150,100], [160,50], [170,100], [180,50]]];

        function normalizeCoordinates(points, canvasWidth, canvasHeight) {
            return points.map(([x, y]) => [
                (x / canvasWidth) * 2 - 1,
                1 - (y / canvasHeight) * 2
            ]);
        }

        function normalizeVector([x, y]) {
            const len = Math.sqrt(x * x + y * y);
            return len > 0 ? [x / len, y / len] : [0, 0];
        }

        function createArc(cx, cy, radius, startAngle, endAngle, segments, clockwise) {
            const arc = [];
            const deltaAngle = (endAngle - startAngle) / segments * (clockwise ? 1 : -1);
            for (let i = 0; i <= segments; i++) {
                const angle = startAngle + deltaAngle * i;
                arc.push([
                    cx + Math.cos(angle) * radius,
                    cy + Math.sin(angle) * radius
                ]);
            }
            return arc;
        }

        function calculateUniformThicknessVertices(points, thickness, lineJoin = 'miter', lineCap = 'butt', isClosed = false) {
            const vertices = [];
            const indices = [];
            const normals = [];

            // 법선 계산
            for (let i = 0; i < points.length - 1; i++) {
                const [x1, y1] = points[i];
                const [x2, y2] = points[i + 1];
                const [dx, dy] = normalizeVector([x2 - x1, y2 - y1]);
                normals.push([-dy * thickness, dx * thickness]);
            }
            normals.push(normals[normals.length - 1]); // 마지막 점은 이전 법선 사용

            // 열린 경로의 시작 캡
            if (!isClosed && lineCap !== 'butt') {
                const [x, y] = points[0];
                const [nx, ny] = normals[0];
                const baseIndex = vertices.length / 2;
                if (lineCap === 'square') {
                    const [dirX, dirY] = normalizeVector([points[1][0] - x, points[1][1] - y]);
                    vertices.push(x - dirX * thickness + nx, y - dirY * thickness + ny);
                    vertices.push(x - dirX * thickness - nx, y - dirY * thickness - ny);
                } else if (lineCap === 'round') {
                    const startAngle = Math.atan2(-ny, -nx);
                    const endAngle = Math.atan2(ny, nx);
                    const arcPath = createArc(x, y, thickness, startAngle, endAngle, 10, true);
                    for (const [px, py] of arcPath) {
                        vertices.push(px, py);
                    }
                    for (let j = 0; j < arcPath.length - 1; j++) {
                        indices.push(baseIndex, baseIndex + j, baseIndex + j + 1);
                    }
                }
            }

            // 선분과 조인트
            for (let i = 0; i < points.length - 1; i++) {
                const [x1, y1] = points[i];
                const [x2, y2] = points[i + 1];
                const [nx1, ny1] = normals[i];
                const [nx2, ny2] = normals[i + 1];

                const baseIndex = vertices.length / 2;
                vertices.push(x1 + nx1, y1 + ny1); // 상단 시작
                vertices.push(x1 - nx1, y1 - ny1); // 하단 시작
                vertices.push(x2 + nx2, y2 + ny2); // 상단 끝
                vertices.push(x2 - nx2, y2 - ny2); // 하단 끝

                indices.push(baseIndex, baseIndex + 1, baseIndex + 2);
                indices.push(baseIndex + 1, baseIndex + 3, baseIndex + 2);

                // 조인트 처리
                if (i < points.length - 2 || isClosed) {
                    const nextIdx = (i + 1) % points.length;
                    const [xJoin, yJoin] = points[nextIdx];
                    const joinBase = vertices.length / 2;

                    if (lineJoin === 'bevel') {
                        vertices.push(xJoin + nx2, yJoin + ny2);
                        vertices.push(xJoin - nx2, yJoin - ny2);
                        indices.push(baseIndex + 2, baseIndex + 3, joinBase);
                        indices.push(baseIndex + 3, joinBase + 1, joinBase);
                    } else if (lineJoin === 'round') {
                        const startAngle = Math.atan2(ny1, nx1);
                        const endAngle = Math.atan2(ny2, nx2);
                        const arcPath = createArc(xJoin, yJoin, thickness, startAngle, endAngle, 10, true);
                        for (const [px, py] of arcPath) {
                            vertices.push(px, py);
                        }
                        for (let j = 0; j < arcPath.length - 1; j++) {
                            indices.push(baseIndex + 2, joinBase + j, joinBase + j + 1);
                        }
                    } // miter는 기본적으로 직선 연결
                }
            }

            // 열린 경로의 끝 캡
            if (!isClosed && lineCap !== 'butt') {
                const idx = points.length - 1;
                const [x, y] = points[idx];
                const [nx, ny] = normals[idx - 1];
                const baseIndex = vertices.length / 2;

                if (lineCap === 'square') {
                    const [dirX, dirY] = normalizeVector([x - points[idx - 1][0], y - points[idx - 1][1]]);
                    vertices.push(x + dirX * thickness + nx, y + dirY * thickness + ny);
                    vertices.push(x + dirX * thickness - nx, y + dirY * thickness - ny);
                    indices.push(baseIndex - 2, baseIndex - 1, baseIndex);
                    indices.push(baseIndex - 1, baseIndex + 1, baseIndex);
                } else if (lineCap === 'round') {
                    const startAngle = Math.atan2(-ny, -nx);
                    const endAngle = Math.atan2(ny, nx);
                    const arcPath = createArc(x, y, thickness, startAngle, endAngle, 10, false);
                    for (const [px, py] of arcPath) {
                        vertices.push(px, py);
                    }
                    for (let j = 0; j < arcPath.length - 1; j++) {
                        indices.push(baseIndex - 2, baseIndex + j, baseIndex + j + 1);
                    }
                }
            }

            return { vertices: new Float32Array(vertices), indices: new Uint16Array(indices) };
        }

        const points = normalizeCoordinates(paths[0], canvas.width, canvas.height);
        const thickness = 0.05;
        const { vertices, indices } = calculateUniformThicknessVertices(points, thickness, 'miter', 'butt', false);

        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const colorLocation = gl.getUniformLocation(program, 'u_color');

        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 2 * Float32Array.BYTES_PER_ELEMENT, 0);

        const color = [1.0, 0.0, 0.0]; // 빨간색

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(program);
        gl.uniform3fv(colorLocation, color);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    </script>
</body>
</html>
