<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL GIS LineString Rendering</title>
    <style>
        canvas { border: 1px solid black; }
    </style>
</head>
<body>
    <canvas id="canvas" width="400" height="400"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL이 지원되지 않습니다.');
            throw new Error('WebGL not supported');
        }

        const vertexShaderSource = `
        attribute vec2 a_position;
        uniform vec3 u_color;
        uniform float u_thickness;
        varying vec3 v_color;

        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_color = u_color;
        }
        `;

        const fragmentShaderSource = `
        precision mediump float;
        varying vec3 v_color;

        void main() {
            gl_FragColor = vec4(v_color, 1.0);
        }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // GIS LineString 좌표
        const coordinates = [[10, 75], [90, 100], [130, 50], [150, 100], [160, 50], [170, 100], [180, 50]];
        const thickness = 0.05; // WebGL 좌표계에서의 두께
        const color = [1.0, 0.0, 0.0]; // 빨간색

        // 좌표를 WebGL 좌표계로 변환
        function normalizeCoordinates(coords, canvasWidth, canvasHeight) {
            // 좌표 범위 찾기
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            coords.forEach(([x, y]) => {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            });

            const rangeX = maxX - minX || 1; // 0 방지
            const rangeY = maxY - minY || 1;
            const scale = Math.min(canvasWidth / rangeX, canvasHeight / rangeY) * 0.9; // 90% 크기로 맞춤

            // 캔버스 중심에 맞추기 위한 오프셋
            const offsetX = (canvasWidth - rangeX * scale) / 2;
            const offsetY = (canvasHeight - rangeY * scale) / 2;

            return coords.map(([x, y]) => {
                // WebGL 좌표계 (-1 ~ 1)로 변환
                const nx = ((x - minX) * scale + offsetX) / (canvasWidth / 2) - 1;
                const ny = ((y - minY) * scale + offsetY) / (canvasHeight / 2) - 1;
                return [nx, ny];
            });
        }

function calculateNormalsAndVertices(points, thickness) {
    const vertices = [];
    const indices = [];
    const normals = [];

    for (let i = 0; i < points.length; i++) {
        let prev = points[Math.max(0, i - 1)];
        let curr = points[i];
        let next = points[Math.min(points.length - 1, i + 1)];

        // 현재 선분과 이전 선분의 방향 벡터
        let dirPrev = [curr[0] - prev[0], curr[1] - prev[1]];
        let dirNext = [next[0] - curr[0], next[1] - curr[1]];
        
        // 수직 벡터 계산 (정규화 후 두께 적용)
        const normalPrev = normalize([dirPrev[1], -dirPrev[0]]);
        const normalNext = normalize([dirNext[1], -dirNext[0]]);

        // 조인 방향 계산 (miter)
        const tangent = normalize([
            normalPrev[0] + normalNext[0],
            normalPrev[1] + normalNext[1]
        ]);
        
        // miter length 계산
        const miterLength = 1 / Math.max(Math.sqrt(tangent[0]*tangent[0] + tangent[1]*tangent[1]), 0.001);
        const normal = [tangent[0] * miterLength, tangent[1] * miterLength];
        
        normals.push([
            normal[0] * thickness,
            normal[1] * thickness
        ]);
    }

    // 나머지 정점 생성 로직은 유지...
}

function normalize(v) {
    const length = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
    return [v[0]/length, v[1]/length];
}

        // 정규화된 좌표 계산
        const normalizedPoints = normalizeCoordinates(coordinates, canvas.width, canvas.height);
        const { vertices, indices } = calculateNormalsAndVertices(normalizedPoints, thickness);

        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const colorLocation = gl.getUniformLocation(program, 'u_color');
        const thicknessLocation = gl.getUniformLocation(program, 'u_thickness');

        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 2 * Float32Array.BYTES_PER_ELEMENT, 0);

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(program);
        
        gl.uniform3fv(colorLocation, color);
        gl.uniform1f(thicknessLocation, thickness);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    </script>
</body>
</html>
