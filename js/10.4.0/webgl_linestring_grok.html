<!DOCTYPE html>
<html>
<head>
    <title>Thick Linestring WebGL2</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <script>
        // WebGL2 컨텍스트 설정
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        document.body.appendChild(canvas);

        const gl = canvas.getContext('webgl2');
        if (!gl) {
            console.error('WebGL2 is not supported');
        }

        // Vertex Shader
        const vertexShaderSource = `#version 300 es
        in vec2 in_position;
        in vec2 in_startPos;
        in vec2 in_endPos;
        in vec2 in_prevPos;
        in vec2 in_nextPos;
        in float in_lineWidth;

        out vec2 v_startPos;
        out vec2 v_endPos;
        out vec2 v_startMiterVec;
        out vec2 v_endMiterVec;
        out float v_lineWidth;

        uniform vec2 u_resolution;

        mat3 getTransformMatrix(vec2 startPos, vec2 endPos, float lineWidth) {
            vec2 centerPos = (startPos + endPos) / 2.;
            vec2 delta = endPos - startPos;
            float len = length(delta);
            float phi = atan(delta.y / delta.x);
            
            mat3 scale = mat3(
                len, 0, 0,
                0, lineWidth, 0,
                0, 0, 1
            );

            mat3 rotate = mat3(
                cos(phi), sin(phi), 0,
                -sin(phi), cos(phi), 0,
                0, 0, 1
            );
            
            mat3 translate = mat3(
                1, 0, 0,
                0, 1, 0,
                centerPos.x, centerPos.y, 1
            );
            
            return translate * rotate * scale;
        }

        vec2 getOffsetVec(vec2 pos, vec2 prev, vec2 next) {
            if (pos == prev || pos == next) {
                return vec2(0., 0.);
            }
            vec2 line1 = pos - prev;
            vec2 normal1 = normalize(vec2(-line1.y, line1.x));
            vec2 line2 = next - pos;
            vec2 normal2 = normalize(vec2(-line2.y, line2.x));
            vec2 normal = normalize(normal1 + normal2);
            vec2 vec = normal * 1. / abs(dot(normal, normal1));
            return -vec;
        }

        void main() {
            vec2 v1 = getOffsetVec(in_startPos, in_prevPos, in_endPos) * in_lineWidth / 2.;
            vec2 v2 = getOffsetVec(in_endPos, in_startPos, in_nextPos) * in_lineWidth / 2.;
            vec2 dir = normalize(in_endPos - in_startPos);
            vec2 startOffset = (v1 == vec2(0., 0.) ? -in_lineWidth / 2. : dot(v1, dir)) * dir;
            vec2 endOffset = (v2 == vec2(0., 0.) ? in_lineWidth / 2. : dot(v2, dir)) * dir;
            mat3 transformMatrix = getTransformMatrix(in_startPos + startOffset, in_endPos + endOffset, in_lineWidth);
            vec2 pos = (transformMatrix * vec3(in_position, 1.)).xy;

            vec2 zeroToOne = pos.xy / u_resolution;
            vec2 zeroToTwo = zeroToOne * 2.0;
            vec2 clipSpace = zeroToTwo - 1.0;

            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

            v_startPos = in_startPos;
            v_endPos = in_endPos;
            v_startMiterVec = v1;
            v_endMiterVec = v2;
            v_lineWidth = in_lineWidth;
        }`;

        // Fragment Shader
        const fragmentShaderSource = `#version 300 es
        precision highp float;

        in vec2 v_startPos;
        in vec2 v_endPos;
        in vec2 v_startMiterVec;
        in vec2 v_endMiterVec;
        in float v_lineWidth;

        out vec4 fragColor;

        uniform float u_lineJoin;
        uniform float u_lineCap;

        void main() {
            vec2 p = gl_FragCoord.xy;
            
            if (v_startMiterVec == vec2(0., 0.)) {
                bool outStartMainLine = dot((p - v_startPos), (v_endPos - v_startPos)) < 0.;
                if (u_lineCap == 0.) {
                    if (outStartMainLine) discard;
                } else if (u_lineCap == 2.) {
                    if (outStartMainLine && distance(p, v_startPos) > v_lineWidth / 2.) discard;
                }
            }

            if (v_endMiterVec == vec2(0., 0.)) {
                bool outEndMainLine = dot((p - v_endPos), (v_startPos - v_endPos)) < 0.;
                if (u_lineCap == 0.) {
                    if (outEndMainLine) discard;
                } else if (u_lineCap == 2.) {
                    if (outEndMainLine && distance(p, v_endPos) > v_lineWidth / 2.) discard;
                }
            }

            vec2 miterNormal1 = vec2(-v_startMiterVec.y, v_startMiterVec.x);
            vec2 miterNormal2 = vec2(-v_endMiterVec.y, v_endMiterVec.x);
            bool outside = dot((p - v_startPos), miterNormal1) < 0. || dot((p - v_endPos), miterNormal2) > 0.;
            if (outside) discard;

            fragColor = vec4(0., 0., 0., 1.);
        }`;

        // Shader 프로그램 생성 함수들
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            
            return program;
        }

        const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
        gl.useProgram(program);

        // Uniform 위치
        const uResolutionLoc = gl.getUniformLocation(program, 'u_resolution');
        const uLineJoinLoc = gl.getUniformLocation(program, 'u_lineJoin');
        const uLineCapLoc = gl.getUniformLocation(program, 'u_lineCap');

        // Attribute 위치
        const positionLoc = gl.getAttribLocation(program, 'in_position');
        const startPosLoc = gl.getAttribLocation(program, 'in_startPos');
        const endPosLoc = gl.getAttribLocation(program, 'in_endPos');
        const prevPosLoc = gl.getAttribLocation(program, 'in_prevPos');
        const nextPosLoc = gl.getAttribLocation(program, 'in_nextPos');
        const lineWidthLoc = gl.getAttribLocation(program, 'in_lineWidth');

        // VAO 및 VBO 설정
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);

        // 예시 데이터
        const points = [
            200, 500,  // 점 1
            400, 200,  // 점 2
            600, 500   // 점 3
        ];
        const lineWidth = 20.0;

        const positions = new Float32Array([
            -0.5, -0.5,
            -0.5,  0.5,
             0.5, -0.5,
             0.5,  0.5
        ]);

        const startPos = new Float32Array([
            points[0], points[1], points[0], points[1], points[0], points[1], points[0], points[1],
            points[2], points[3], points[2], points[3], points[2], points[3], points[2], points[3]
        ]);

        const endPos = new Float32Array([
            points[2], points[3], points[2], points[3], points[2], points[3], points[2], points[3],
            points[4], points[5], points[4], points[5], points[4], points[5], points[4], points[5]
        ]);

        const prevPos = new Float32Array([
            points[0], points[1], points[0], points[1], points[0], points[1], points[0], points[1],
            points[0], points[1], points[0], points[1], points[0], points[1 Срби

            points[0], points[1]
        ]);

        const nextPos = new Float32Array([
            points[4], points[5], points[4], points[5], points[4], points[5], points[4], points[5],
            points[4], points[5], points[4], points[5], points[4], points[5], points[4], points[5]
        ]);

        const lineWidths = new Float32Array(8).fill(lineWidth);

        const indices = new Uint16Array([
            0, 1, 2,  2, 1, 3,
            4, 5, 6,  6, 5, 7
        ]);

        // 버퍼 생성 함수
        function createBuffer(gl, data, type = gl.ARRAY_BUFFER) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(type, buffer);
            gl.bufferData(type, data, gl.STATIC_DRAW);
            return buffer;
        }

        const positionBuffer = createBuffer(gl, positions);
        const startPosBuffer = createBuffer(gl, startPos);
        const endPosBuffer = createBuffer(gl, endPos);
        const prevPosBuffer = createBuffer(gl, prevPos);
        const nextPosBuffer = createBuffer(gl, nextPos);
        const lineWidthBuffer = createBuffer(gl, lineWidths);
        const indexBuffer = createBuffer(gl, indices, gl.ELEMENT_ARRAY_BUFFER);

        // Attribute 설정 함수
        function setupAttribute(gl, loc, buffer, size) {
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.enableVertexAttribArray(loc);
            gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
        }

        setupAttribute(gl, positionLoc, positionBuffer, 2);
        setupAttribute(gl, startPosLoc, startPosBuffer, 2);
        setupAttribute(gl, endPosLoc, endPosBuffer, 2);
        setupAttribute(gl, prevPosLoc, prevPosBuffer, 2);
        setupAttribute(gl, nextPosLoc, nextPosBuffer, 2);
        setupAttribute(gl, lineWidthLoc, lineWidthBuffer, 1);

        // 렌더링 함수
        function render() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(1, 1, 1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.uniform2f(uResolutionLoc, canvas.width, canvas.height);
            gl.uniform1f(uLineJoinLoc, 0.0); // 0: miter, 1: bevel, 2: round
            gl.uniform1f(uLineCapLoc, 2.0);  // 0: butt, 1: square, 2: round

            gl.bindVertexArray(vao);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        render();
    </script>
</body>
</html>
