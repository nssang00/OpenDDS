<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Thick Polyline - Fixed Round Joins</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        min-height: 100vh;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        padding: 20px;
        background: linear-gradient(135deg, #4776e6, #8e54e9);
        color: #e6e6e6;
      }
      header {
        margin-bottom: 20px;
        text-align: center;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      h1 {
        font-size: 2.2rem;
        margin-bottom: 8px;
        color: #4cc9f0;
        text-shadow: 0 0 10px rgba(76, 201, 240, 0.3);
      }
      .subtitle {
        opacity: 0.8;
      }
      .container {
        flex: 1;
        display: flex;
        gap: 20px;
      }
      .controls {
        width: 300px;
        padding: 20px;
        border-radius: 10px;
        backdrop-filter: blur(5px);
        background: rgba(255, 255, 255, 0.05);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }
      .control-group {
        margin-bottom: 25px;
      }
      h2 {
        font-size: 1.3rem;
        margin-bottom: 15px;
        color: #f72585;
      }
      label {
        font-size: 0.95rem;
        margin: 10px 0 5px;
        display: block;
      }
      input[type="range"] {
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
      }
      select,
      button {
        width: 100%;
        padding: 10px;
        border-radius: 5px;
        cursor: pointer;
        transition: 0.3s;
        font-size: 1rem;
        color: #e6e6e6;
      }
      select {
        background: rgba(76, 201, 240, 0.15);
        border: 1px solid rgba(76, 201, 240, 0.3);
      }
      select:hover {
        background: rgba(76, 201, 240, 0.25);
        border-color: rgba(76, 201, 240, 0.5);
      }
      button {
        margin-top: 15px;
        font-weight: 700;
        background: rgba(247, 37, 133, 0.2);
        border: 1px solid rgba(247, 37, 133, 0.4);
      }
      button:hover {
        background: rgba(247, 37, 133, 0.3);
      }
      .canvas-container {
        flex: 1;
        position: relative;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        background: rgba(0, 0, 0, 0.3);
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      .info-panel {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-size: 0.9rem;
        background: rgba(0, 0, 0, 0.5);
        padding: 15px;
        border-radius: 8px;
        max-width: 300px;
      }
      .join-examples {
        display: flex;
        justify-content: space-between;
        margin-top: 15px;
        text-align: center;
      }
      .join-example {
        flex: 1;
        margin: 0 5px;
        padding: 10px;
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.05);
      }
      .join-title {
        font-weight: 700;
        color: #4cc9f0;
        margin-bottom: 5px;
      }
      .join-desc {
        font-size: 0.8rem;
        opacity: 0.7;
      }
      .value-display {
        min-width: 40px;
        display: inline-block;
        text-align: right;
        color: #4cc9f0;
        font-weight: 700;
      }
      @media (max-width: 768px) {
        .container {
          flex-direction: column;
        }
        .controls {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Thick Polyline with WebGL</h1>
      <p class="subtitle">Round-Join Crack Fix Applied</p>
    </header>

    <div class="container">
      <div class="controls">
        <div class="control-group">
          <h2>Line Properties</h2>
          <label
            >Join Type:
            <select id="join-type">
              <option value="miter">Miter</option>
              <option value="bevel">Bevel</option>
              <option value="round" selected>Round</option>
            </select>
          </label>

          <label
            >Line Width:
            <span id="width-val" class="value-display">24</span> px</label
          >
          <input type="range" id="line-width" min="5" max="60" value="24" />

          <label
            >Miter Limit:
            <span id="miter-val" class="value-display">4.0</span></label
          >
          <input
            type="range"
            id="miter-limit"
            min="1"
            max="10"
            step=".5"
            value="4"
          />
        </div>

        <div class="control-group">
          <h2>Appearance</h2>
          <label
            >Line Color:
            <select id="line-color">
              <option value="#FF3B30">Red</option>
              <option value="#4CD964" selected>Green</option>
              <option value="#5AC8FA">Blue</option>
              <option value="#FF9500">Orange</option>
              <option value="#FFCC00">Yellow</option>
              <option value="#AF52DE">Purple</option>
            </select>
          </label>

          <label
            >Background:
            <select id="bg-theme">
              <option value="dark">Dark</option>
              <option value="light">Light</option>
              <option value="blue">Blue Gradient</option>
              <option value="purple" selected>Purple Gradient</option>
            </select>
          </label>
        </div>
        <button id="reset-btn">Reset</button>
      </div>

      <div class="canvas-container">
        <canvas id="glcanvas"></canvas>
        <div class="info-panel">
          <div id="vertex-info">Vertices: 0</div>
          <div id="segment-info">Triangles: 0</div>
          <div class="join-examples">
            <div class="join-example">
              <div class="join-title">Miter</div>
              <div class="join-desc">Sharp</div>
            </div>
            <div class="join-example">
              <div class="join-title">Bevel</div>
              <div class="join-desc">Flat</div>
            </div>
            <div class="join-example">
              <div class="join-title">Round</div>
              <div class="join-desc">Smooth</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <footer
      style="text-align: center; opacity: 0.7; padding: 20px; font-size: 0.9rem"
    >
      WebGL thick-polyline demo – round-join cracks fixed ✓
    </footer>

    <script>
      // ───────── Sample path (MapLibre/dev route) ─────────
      const route = [
        [-122.48369693756104, 37.83381888486939],
        [-122.48348236083984, 37.83317489144141],
        [-122.48339653015138, 37.83270036637107],
        [-122.48356819152832, 37.832056363179625],
        [-122.48404026031496, 37.83114119107971],
        [-122.48404026031496, 37.83049717427869],
        [-122.48348236083984, 37.829920943955045],
        [-122.48356819152832, 37.82954808664175],
        [-122.48507022857666, 37.82944639795659],
        [-122.48610019683838, 37.82880236636284],
        [-122.48695850372314, 37.82931081282506],
        [-122.48700141906738, 37.83080223556934],
        [-122.48751640319824, 37.83168351665737],
        [-122.48803138732912, 37.832158048267786],
        [-122.48888969421387, 37.83297152392784],
        [-122.48987674713133, 37.83263257682617],
        [-122.49043464660643, 37.832937629287755],
        [-122.49125003814696, 37.832429207817725],
        [-122.49163627624512, 37.832564787218985],
        [-122.49223709106445, 37.83337825839438],
        [-122.49378204345702, 37.83368330777276],
      ];

      // ───────── Math helpers ─────────
      const R = 6378137,
        rad = (d) => (d * Math.PI) / 180,
        toXY = ([lng, lat], bLat) => [
          rad(lng) * R * Math.cos(rad(bLat)),
          rad(lat) * R,
        ];
      const sub = (a, b) => [a[0] - b[0], a[1] - b[1]],
        add = (a, b) => [a[0] + b[0], a[1] + b[1]],
        scale = (v, s) => [v[0] * s, v[1] * s];
      const len = (v) => Math.hypot(v[0], v[1]),
        norm = (v) => {
          const l = len(v);
          return l ? [v[0] / l, v[1] / l] : [0, 0];
        },
        perp = (v) => [-v[1], v[0]];
      const dot = (a, b) => a[0] * b[0] + a[1] * b[1],
        cross = (a, b) => a[0] * b[1] - a[1] * b[0],
        angleBetween = (a, b) =>
          Math.acos(Math.max(-1, Math.min(1, dot(a, b))));
      const rotate = (v, a) => {
        const c = Math.cos(a),
          s = Math.sin(a);
        return [v[0] * c - v[1] * s, v[0] * s + v[1] * c];
      };

      // ───────── Optimized mesh builder ─────────
      // Precompute route to XY once
      const baseLat = route[0][1];
      const routeXY = route.map((c) => toXY(c, baseLat));

      function buildMesh(pts, width = 24, join = "round", miterLimit = 4) {
        const dir = [],
          normL = [];
        for (let i = 0; i < pts.length - 1; i++) {
          const d = norm(sub(pts[i + 1], pts[i]));
          dir.push(d);
          normL.push(perp(d));
        }

        // Pre-calculate vertex count
        let vertexCount = 2; // Start cap
        let indexCount = 0;

        for (let i = 1; i < pts.length - 1; i++) {
          if (join === "round") {
            const nPrev = normL[i - 1],
              nNext = normL[i],
              ang = angleBetween(nPrev, nNext),
              segs = Math.max(4, Math.min(16, Math.ceil(ang * 8)));
            vertexCount += 2 * (segs + 1);
            indexCount += 6 * segs + 6;
          } else {
            vertexCount += 4;
            indexCount += 12;
          }
        }

        // End cap
        vertexCount += 2;
        indexCount += 6;

        const vertices = new Float32Array(vertexCount * 2);
        const indices = new Uint16Array(indexCount);
        let vIdx = 0,
          iIdx = 0;

        // Pre-allocated arrays
        const v = vertices;
        const idx = indices;

        // first cap
        v[vIdx++] = pts[0][0] + (normL[0][0] * width) / 2;
        v[vIdx++] = pts[0][1] + (normL[0][1] * width) / 2;
        v[vIdx++] = pts[0][0] - (normL[0][0] * width) / 2;
        v[vIdx++] = pts[0][1] - (normL[0][1] * width) / 2;
        let vc = 2;

        for (let i = 1; i < pts.length - 1; i++) {
          const nPrev = normL[i - 1],
            nNext = normL[i],
            e = add(nPrev, nNext),
            eLen = len(e);

          if (join === "bevel" || (join === "miter" && eLen < 1e-6)) {
            const l1x = pts[i][0] + (nPrev[0] * width) / 2;
            const l1y = pts[i][1] + (nPrev[1] * width) / 2;
            const r1x = pts[i][0] - (nPrev[0] * width) / 2;
            const r1y = pts[i][1] - (nPrev[1] * width) / 2;
            const l2x = pts[i][0] + (nNext[0] * width) / 2;
            const l2y = pts[i][1] + (nNext[1] * width) / 2;
            const r2x = pts[i][0] - (nNext[0] * width) / 2;
            const r2y = pts[i][1] - (nNext[1] * width) / 2;

            v[vIdx++] = l1x;
            v[vIdx++] = l1y;
            v[vIdx++] = r1x;
            v[vIdx++] = r1y;
            v[vIdx++] = l2x;
            v[vIdx++] = l2y;
            v[vIdx++] = r2x;
            v[vIdx++] = r2y;

            idx[iIdx++] = vc - 2;
            idx[iIdx++] = vc - 1;
            idx[iIdx++] = vc;
            idx[iIdx++] = vc - 1;
            idx[iIdx++] = vc + 1;
            idx[iIdx++] = vc;
            idx[iIdx++] = vc;
            idx[iIdx++] = vc + 1;
            idx[iIdx++] = vc + 2;
            idx[iIdx++] = vc + 1;
            idx[iIdx++] = vc + 3;
            idx[iIdx++] = vc + 2;

            vc += 4;
          } else if (join === "round") {
            // Optimized round join
            const ang = angleBetween(nPrev, nNext);
            const rotDir = cross(nPrev, nNext) > 0 ? 1 : -1;
            const segs = Math.max(4, Math.min(16, Math.ceil(ang * 8)));
            const da = (ang * rotDir) / segs;
            const cosDa = Math.cos(da);
            const sinDa = Math.sin(da);

            // Start vertices
            v[vIdx++] = pts[i][0] + (nPrev[0] * width) / 2;
            v[vIdx++] = pts[i][1] + (nPrev[1] * width) / 2;
            v[vIdx++] = pts[i][0] - (nPrev[0] * width) / 2;
            v[vIdx++] = pts[i][1] - (nPrev[1] * width) / 2;

            // Connect with previous segment
            idx[iIdx++] = vc - 2;
            idx[iIdx++] = vc - 1;
            idx[iIdx++] = vc;
            idx[iIdx++] = vc - 1;
            idx[iIdx++] = vc + 1;
            idx[iIdx++] = vc;

            vc += 2;

            // Current vector
            let vec = [...nPrev];

            // Generate round segments with incremental rotation
            for (let j = 1; j <= segs; j++) {
              // Rotate vector incrementally
              const newX = vec[0] * cosDa - vec[1] * sinDa;
              const newY = vec[0] * sinDa + vec[1] * cosDa;
              vec[0] = newX;
              vec[1] = newY;

              // Calculate new points
              v[vIdx++] = pts[i][0] + (vec[0] * width) / 2;
              v[vIdx++] = pts[i][1] + (vec[1] * width) / 2;
              v[vIdx++] = pts[i][0] - (vec[0] * width) / 2;
              v[vIdx++] = pts[i][1] - (vec[1] * width) / 2;

              // Add indices
              idx[iIdx++] = vc - 2;
              idx[iIdx++] = vc - 1;
              idx[iIdx++] = vc;
              idx[iIdx++] = vc - 1;
              idx[iIdx++] = vc + 1;
              idx[iIdx++] = vc;

              vc += 2;
            }
          } else {
            // miter
            const eHat = norm(e),
              mLen = width / 2 / Math.max(0.1, dot(eHat, nPrev));
            if (join === "miter" && mLen > width * miterLimit) {
              // fallback to bevel
              const l1x = pts[i][0] + (nPrev[0] * width) / 2;
              const l1y = pts[i][1] + (nPrev[1] * width) / 2;
              const r1x = pts[i][0] - (nPrev[0] * width) / 2;
              const r1y = pts[i][1] - (nPrev[1] * width) / 2;
              const l2x = pts[i][0] + (nNext[0] * width) / 2;
              const l2y = pts[i][1] + (nNext[1] * width) / 2;
              const r2x = pts[i][0] - (nNext[0] * width) / 2;
              const r2y = pts[i][1] - (nNext[1] * width) / 2;

              v[vIdx++] = l1x;
              v[vIdx++] = l1y;
              v[vIdx++] = r1x;
              v[vIdx++] = r1y;
              v[vIdx++] = l2x;
              v[vIdx++] = l2y;
              v[vIdx++] = r2x;
              v[vIdx++] = r2y;

              idx[iIdx++] = vc - 2;
              idx[iIdx++] = vc - 1;
              idx[iIdx++] = vc;
              idx[iIdx++] = vc - 1;
              idx[iIdx++] = vc + 1;
              idx[iIdx++] = vc;
              idx[iIdx++] = vc;
              idx[iIdx++] = vc + 1;
              idx[iIdx++] = vc + 2;
              idx[iIdx++] = vc + 1;
              idx[iIdx++] = vc + 3;
              idx[iIdx++] = vc + 2;

              vc += 4;
            } else {
              const extX = eHat[0] * mLen;
              const extY = eHat[1] * mLen;
              v[vIdx++] = pts[i][0] + extX;
              v[vIdx++] = pts[i][1] + extY;
              v[vIdx++] = pts[i][0] - extX;
              v[vIdx++] = pts[i][1] - extY;

              idx[iIdx++] = vc - 2;
              idx[iIdx++] = vc - 1;
              idx[iIdx++] = vc;
              idx[iIdx++] = vc - 1;
              idx[iIdx++] = vc + 1;
              idx[iIdx++] = vc;

              vc += 2;
            }
          }
        }

        // last segment and cap
        const nLast = normL[normL.length - 1];
        v[vIdx++] = pts[pts.length - 1][0] + (nLast[0] * width) / 2;
        v[vIdx++] = pts[pts.length - 1][1] + (nLast[1] * width) / 2;
        v[vIdx++] = pts[pts.length - 1][0] - (nLast[0] * width) / 2;
        v[vIdx++] = pts[pts.length - 1][1] - (nLast[1] * width) / 2;

        idx[iIdx++] = vc - 2;
        idx[iIdx++] = vc - 1;
        idx[iIdx++] = vc;
        idx[iIdx++] = vc - 1;
        idx[iIdx++] = vc + 1;
        idx[iIdx++] = vc;
        vc += 2;

        // Normalize to clip-space
        let minX = Infinity,
          maxX = -Infinity,
          minY = Infinity,
          maxY = -Infinity;
        for (let i = 0; i < v.length; i += 2) {
          minX = Math.min(minX, v[i]);
          maxX = Math.max(maxX, v[i]);
          minY = Math.min(minY, v[i + 1]);
          maxY = Math.max(maxY, v[i + 1]);
        }

        const s = 0.9 / Math.max(maxX - minX, maxY - minY),
          cX = (minX + maxX) / 2,
          cY = (minY + maxY) / 2;

        for (let i = 0; i < v.length; i += 2) {
          v[i] = (v[i] - cX) * s;
          v[i + 1] = (v[i + 1] - cY) * s;
        }

        return {
          vertices: v,
          indices: idx,
          vc: v.length / 2,
          sc: idx.length / 3,
        };
      }

      // ───────── WebGL init ─────────
      const canvas = document.getElementById("glcanvas"),
        gl = canvas.getContext("webgl", { antialias: true });
      if (!gl) alert("WebGL unsupported");

      const vsSrc = `attribute vec2 a_xy;void main(){gl_Position=vec4(a_xy,0.0,1.0);}`;
      const fsSrc = `precision mediump float;uniform vec4 u_color;void main(){gl_FragColor=u_color;}`;

      function compile(t, s) {
        const sh = gl.createShader(t);
        gl.shaderSource(sh, s);
        gl.compileShader(sh);
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS))
          throw gl.getShaderInfoLog(sh);
        return sh;
      }

      const prog = gl.createProgram();
      gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsSrc));
      gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsSrc));
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
        throw gl.getProgramInfoLog(prog);
      gl.useProgram(prog);

      const locXY = gl.getAttribLocation(prog, "a_xy"),
        locClr = gl.getUniformLocation(prog, "u_color");
      let vbo = null,
        ebo = null,
        current = { vertices: new Float32Array(), indices: new Uint16Array() };

      function upload(mesh) {
        if (!vbo) {
          vbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          gl.enableVertexAttribArray(locXY);
          gl.vertexAttribPointer(locXY, 2, gl.FLOAT, false, 0, 0);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);

        if (!ebo) {
          ebo = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);

        document.getElementById(
          "vertex-info"
        ).textContent = `Vertices: ${mesh.vc}`;
        document.getElementById(
          "segment-info"
        ).textContent = `Triangles: ${mesh.sc}`;
      }

      function render() {
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        if (current.indices.length)
          gl.drawElements(
            gl.TRIANGLES,
            current.indices.length,
            gl.UNSIGNED_SHORT,
            0
          );
      }

      function hex2rgb(hex) {
        hex = hex.replace(/^#/, "");
        return {
          r: parseInt(hex.substring(0, 2), 16) / 255,
          g: parseInt(hex.substring(2, 4), 16) / 255,
          b: parseInt(hex.substring(4, 6), 16) / 255,
        };
      }

      // ───────── UI wiring ─────────
      const ui = {
        join: document.getElementById("join-type"),
        width: document.getElementById("line-width"),
        miter: document.getElementById("miter-limit"),
        color: document.getElementById("line-color"),
        bg: document.getElementById("bg-theme"),
        reset: document.getElementById("reset-btn"),
        wval: document.getElementById("width-val"),
        mval: document.getElementById("miter-val"),
      };

      const st = {
        join: "round",
        width: 24,
        miter: 4,
        color: "#4CD964",
        bg: "purple",
      };

      function setBg(t) {
        const g = {
          dark: "linear-gradient(135deg,#1a1a2e,#16213e)",
          light: "linear-gradient(135deg,#f5f7fa,#c3cfe2)",
          blue: "linear-gradient(135deg,#1a2a6c,#2a5298)",
          purple: "linear-gradient(135deg,#4776E6,#8E54E9)",
        };
        document.body.style.background = g[t] || g.dark;
      }

      function refresh() {
        current = buildMesh(routeXY, st.width, st.join, st.miter);
        upload(current);
        const c = hex2rgb(st.color);
        gl.uniform4f(locClr, c.r, c.g, c.b, 1);
        render();
      }

      ui.join.onchange = () => {
        st.join = ui.join.value;
        refresh();
      };
      ui.width.oninput = () => {
        st.width = +ui.width.value;
        ui.wval.textContent = st.width;
        refresh();
      };
      ui.miter.oninput = () => {
        st.miter = +ui.miter.value;
        ui.mval.textContent = st.miter.toFixed(1);
        refresh();
      };
      ui.color.onchange = () => {
        st.color = ui.color.value;
        refresh();
      };
      ui.bg.onchange = () => {
        st.bg = ui.bg.value;
        setBg(st.bg);
      };
      ui.reset.onclick = () => {
        Object.assign(st, {
          join: "round",
          width: 24,
          miter: 4,
          color: "#4CD964",
          bg: "purple",
        });
        ui.join.value = st.join;
        ui.width.value = st.width;
        ui.wval.textContent = st.width;
        ui.miter.value = st.miter;
        ui.mval.textContent = st.miter.toFixed(1);
        ui.color.value = st.color;
        ui.bg.value = st.bg;
        setBg(st.bg);
        refresh();
      };

      // Resize with debouncing
      let resizeTimeout;
      function resize() {
        if (resizeTimeout) clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          canvas.width = canvas.clientWidth * devicePixelRatio;
          canvas.height = canvas.clientHeight * devicePixelRatio;
          gl.viewport(0, 0, canvas.width, canvas.height);
          render();
        }, 100);
      }

      window.addEventListener("resize", resize);
      resize();
      setBg(st.bg);
      refresh();
    </script>
  </body>
</html>
