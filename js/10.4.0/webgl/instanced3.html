<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>OpenLayers 스타일 – Instanced Polyline</title>
    <style>
      html,
      body,
      canvas {
        margin: 0;
        width: 100%;
        height: 100%;
        background: #111;
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>
    <script>
      const canvas = document.getElementById("gl");
      const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
      const isGL2 = gl instanceof WebGL2RenderingContext;
      const instEx = isGL2 ? null : gl.getExtension("ANGLE_instanced_arrays");
      if (!isGL2 && !instEx) {
        alert("ANGLE_instanced_arrays 확장 없음");
        throw 0;
      }

      // 1. 위경도 데이터
      const routeLL = [
        [-122.48369693756104, 37.83381888486939],
        [-122.48348236083984, 37.83317489144141],
        [-122.48339653015138, 37.83270036637107],
        [-122.48356819152832, 37.832056363179625],
        [-122.48404026031496, 37.83114119107971],
        [-122.48404026031496, 37.83049717427869],
        [-122.48348236083984, 37.829920943955045],
        [-122.48356819152832, 37.82954808664175],
        [-122.48507022857666, 37.82944639795659],
        [-122.48610019683838, 37.82880236636284],
        [-122.48695850372314, 37.82931081282506],
        [-122.48700141906738, 37.83080223556934],
        [-122.48751640319824, 37.83168351665737],
        [-122.48803138732912, 37.832158048267786],
        [-122.48888969421387, 37.83297152392784],
        [-122.48987674713133, 37.83263257682617],
        [-122.49043464660643, 37.832937629287755],
        [-122.49125003814696, 37.832429207817725],
        [-122.49163627624512, 37.832564787218985],
        [-122.49223709106445, 37.83337825839438],
        [-122.49378204345702, 37.83368330777276],
      ];
      // 경도·위도 → 0~1 정규화
      const lons = routeLL.map((p) => p[0]),
        lats = routeLL.map((p) => p[1]);
      const minLon = Math.min(...lons),
        maxLon = Math.max(...lons);
      const minLat = Math.min(...lats),
        maxLat = Math.max(...lats);
      function lonToX(lon) {
        return (lon - minLon) / (maxLon - minLon);
      }
      function latToY(lat) {
        return (maxLat - lat) / (maxLat - minLat);
      } // y축 뒤집기

      // 2. 셰이더(OL 스타일)
      const VS = `
precision mediump float;
attribute vec2 a_extrude;        // (-1/1, -1/1) 쿼드
attribute vec2 a_segmentStart;   // 인스턴스: 선분 시작점(norm)
attribute vec2 a_segmentEnd;     // 인스턴스: 선분 끝점(norm)
attribute vec2 a_joinAngles;     // 인스턴스: 조인 각 (cosθ, sinθ)
uniform vec2  u_viewSize;
uniform float u_halfWidth;
uniform float u_miterLimit;
void main(){
  // 1. 픽셀 변환
  vec2 startPx = a_segmentStart * u_viewSize;
  vec2 endPx   = a_segmentEnd * u_viewSize;
  vec2 t = normalize(endPx - startPx); // 방향
  vec2 n = vec2(-t.y, t.x);            // 노말
  // 2. offset (노말방향 두께)
  vec2 offset = n * a_extrude.y * u_halfWidth;
  // 3. 조인 처리 (start= -1, end= +1)
  float s = (a_extrude.x + 1.0) * 0.5;
  vec2 posPx = mix(startPx, endPx, s);
  // 4. (시작점에서만) 마이터 계산
  if (s < 0.5) {
    float cosA = a_joinAngles.x, sinA = a_joinAngles.y;
    // bisector = 회전된 노말
    float miterLen = u_halfWidth / max(0.1, cosA);
    if (abs(miterLen) < u_miterLimit * u_halfWidth) {
      // bisector 방향 = (n0 + n1) 단위벡터
      vec2 bisector = normalize(vec2(
        n.x * cosA - n.y * sinA,
        n.x * sinA + n.y * cosA
      ));
      offset = bisector * a_extrude.y * miterLen;
    } else {
      offset = n * a_extrude.y * u_halfWidth; // bevel fallback
    }
  }
  posPx += offset;
  vec2 clip = posPx / u_viewSize * 2.0 - 1.0;
  clip.y = -clip.y;
  gl_Position = vec4(clip, 0.0, 1.0);
}`;
      const FS = `
precision mediump float;
void main(){ gl_FragColor = vec4(0.08,0.8,1.0,1.0); }`;

      // 3. 셰이더 빌드
      function compile(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
          throw gl.getShaderInfoLog(s);
        return s;
      }
      function link(vsSrc, fsSrc) {
        const p = gl.createProgram();
        gl.attachShader(p, compile(gl.VERTEX_SHADER, vsSrc));
        gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fsSrc));
        gl.bindAttribLocation(p, 0, "a_extrude");
        gl.bindAttribLocation(p, 1, "a_segmentStart");
        gl.bindAttribLocation(p, 2, "a_segmentEnd");
        gl.bindAttribLocation(p, 3, "a_joinAngles");
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS))
          throw gl.getProgramInfoLog(p);
        return p;
      }
      const prog = link(VS, FS);
      gl.useProgram(prog);

      // 4. 정적 쿼드 + 인덱스
      const quad = new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]);
      const quadBuf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
      gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
      const indices = new Uint16Array([0, 1, 2, 1, 3, 2]);
      const idxBuf = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      // 5. 인스턴스 버퍼(a_segmentStart, a_segmentEnd, a_joinAngles)
      const segCount = routeLL.length - 1;
      const instData = new Float32Array(segCount * 6); // start(xy)+end(xy)+joinAngle(xy)
      for (let i = 0; i < segCount; i++) {
        const prev = i > 0 ? routeLL[i - 1] : routeLL[0];
        const start = routeLL[i];
        const end = routeLL[i + 1];

        // 두 방향: 이전->시작, 시작->끝
        const t0 = [
          lonToX(start[0]) - lonToX(prev[0]),
          latToY(start[1]) - latToY(prev[1]),
        ];
        const t1 = [
          lonToX(end[0]) - lonToX(start[0]),
          latToY(end[1]) - latToY(start[1]),
        ];
        // 방향 벡터 정규화
        function norm(v) {
          const d = Math.sqrt(v[0] * v[0] + v[1] * v[1]) || 1;
          return [v[0] / d, v[1] / d];
        }
        const n0 = norm([-t0[1], t0[0]]);
        const n1 = norm([-t1[1], t1[0]]);
        // 두 노말 사이 각 (n0·n1, cross 등으로)
        const cosA = n0[0] * n1[0] + n0[1] * n1[1];
        const sinA = n0[0] * n1[1] - n0[1] * n1[0];

        instData.set(
          [
            lonToX(start[0]),
            latToY(start[1]),
            lonToX(end[0]),
            latToY(end[1]),
            cosA,
            sinA,
          ],
          i * 6
        );
      }
      const instBuf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, instBuf);
      gl.bufferData(gl.ARRAY_BUFFER, instData, gl.STATIC_DRAW);

      // 6. VAO & attribute
      const vao = gl.createVertexArray ? gl.createVertexArray() : null;
      if (vao) gl.bindVertexArray(vao);
      // 6-1. 고정 쿼드
      gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
      // 6-2. 인스턴스: a_segmentStart, a_segmentEnd, a_joinAngles
      gl.bindBuffer(gl.ARRAY_BUFFER, instBuf);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 24, 0);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 24, 8);
      gl.enableVertexAttribArray(3);
      gl.vertexAttribPointer(3, 2, gl.FLOAT, false, 24, 16);
      if (isGL2) {
        gl.vertexAttribDivisor(1, 1);
        gl.vertexAttribDivisor(2, 1);
        gl.vertexAttribDivisor(3, 1);
      } else {
        instEx.vertexAttribDivisorANGLE(1, 1);
        instEx.vertexAttribDivisorANGLE(2, 1);
        instEx.vertexAttribDivisorANGLE(3, 1);
      }
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
      if (vao) gl.bindVertexArray(null);

      // 7. uniform & 렌더
      const uViewSize = gl.getUniformLocation(prog, "u_viewSize");
      const uHalfWidth = gl.getUniformLocation(prog, "u_halfWidth");
      const uMiterLimit = gl.getUniformLocation(prog, "u_miterLimit");
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform2f(uViewSize, canvas.width, canvas.height);
      }
      window.addEventListener("resize", resize);
      resize();
      gl.uniform1f(uHalfWidth, 6.0);
      gl.uniform1f(uMiterLimit, 4.0);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      function draw() {
        if (vao) gl.bindVertexArray(vao);
        if (isGL2) {
          gl.drawElementsInstanced(
            gl.TRIANGLES,
            6,
            gl.UNSIGNED_SHORT,
            0,
            segCount
          );
        } else {
          instEx.drawElementsInstancedANGLE(
            gl.TRIANGLES,
            6,
            gl.UNSIGNED_SHORT,
            0,
            segCount
          );
        }
        if (vao) gl.bindVertexArray(null);
      }
      draw();
    </script>
  </body>
</html>
