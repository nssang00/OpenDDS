<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>
      Instanced Thick Polyline - WebGL1/2 (attribute / varying 버전)
    </title>
    <style>
      html,
      body,
      canvas {
        margin: 0;
        width: 100%;
        height: 100%;
        background: #111;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>

    <script>
      /* ─── 1. 컨텍스트 ─── */
      const canvas = document.getElementById("gl");
      const gl =
        canvas.getContext("webgl2") || // 먼저 WebGL2 시도
        canvas.getContext("webgl"); // 없으면 WebGL1
      if (!gl) {
        alert("WebGL 미지원");
        throw 0;
      }
      const isWebGL2 = gl instanceof WebGL2RenderingContext;
      const instExt = isWebGL2
        ? null
        : gl.getExtension("ANGLE_instanced_arrays");
      if (!isWebGL2 && !instExt) {
        alert("ANGLE_instanced_arrays 확장 없음 (WebGL1 인스턴싱 불가)");
        throw 0;
      }

      /* ─── 2. 셰이더(ES 1.00) ─── */
      const VERT_SRC = `
precision mediump float;

attribute vec2 a_extrude;   // (-1|1 , -1|1) 4개 고정정점
attribute vec2 a_startPx;   // 인스턴스: 세그먼트 시작
attribute vec2 a_endPx;     // 인스턴스: 세그먼트 끝

uniform vec2  u_viewSize;   // 캔버스 픽셀 크기
uniform float u_halfWidth;  // 라인 반폭(px)

varying vec2 v_uv;          // (패턴 등 응용 가능)

void main() {
  // 세그먼트 방향·법선 (픽셀 단위)
  vec2 t = normalize(a_endPx - a_startPx);
  vec2 n = vec2(-t.y, t.x);

  float s = (a_extrude.x + 1.0) * 0.5;          // 0(시작) / 1(끝)
  vec2 posPx = mix(a_startPx, a_endPx, s)
             + n * a_extrude.y * u_halfWidth;   // 두께 적용

  // NDC(-1~1) 좌표 변환
  vec2 clip = posPx / u_viewSize * 2.0 - 1.0;
  gl_Position = vec4(clip, 0.0, 1.0);

  v_uv = a_extrude * 0.5 + 0.5;                 // 필요 시 사용
}`;

      const FRAG_SRC = `
precision mediump float;
varying vec2 v_uv;
void main() {
  gl_FragColor = vec4(0.1, 0.8, 1.0, 1.0);      // 시안색 실선
}`;

      /* ─── 3. 셰이더 컴파일 ─── */
      function compileShader(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
          throw gl.getShaderInfoLog(s);
        return s;
      }
      function createProgram(vsSrc, fsSrc) {
        const p = gl.createProgram();
        gl.attachShader(p, compileShader(gl.VERTEX_SHADER, vsSrc));
        gl.attachShader(p, compileShader(gl.FRAGMENT_SHADER, fsSrc));

        // WebGL1: attribute 위치 고정 (0,1,2)
        gl.bindAttribLocation(p, 0, "a_extrude");
        gl.bindAttribLocation(p, 1, "a_startPx");
        gl.bindAttribLocation(p, 2, "a_endPx");

        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS))
          throw gl.getProgramInfoLog(p);
        return p;
      }
      const prog = createProgram(VERT_SRC, FRAG_SRC);
      gl.useProgram(prog);

      /* ─── 4. 정적 쿼드 VBO & 인덱스 ─── */
      const quadData = new Float32Array([
        -1,
        -1, // 0 : start, -normal
        -1,
        1, // 1 : start, +normal
        1,
        -1, // 2 : end  , -normal
        1,
        1, // 3 : end  , +normal
      ]);
      const quadVbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, quadVbo);
      gl.bufferData(gl.ARRAY_BUFFER, quadData, gl.STATIC_DRAW);

      const idxData = new Uint16Array([0, 1, 2, 1, 3, 2]);
      const idxBuf = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idxData, gl.STATIC_DRAW);

      /* ─── 5. 폴리라인 → 인스턴스 버퍼 ─── */
      const route = [
        // 픽셀 경로 예시
        [100, 100],
        [300, 120],
        [350, 220],
        [200, 300],
        [80, 250],
      ];
      const segCount = route.length - 1;
      const instStrideFloats = 4; // start(x,y) + end(x,y)
      const instData = new Float32Array(segCount * instStrideFloats);
      for (let i = 0; i < segCount; i++) {
        instData.set(
          [route[i][0], route[i][1], route[i + 1][0], route[i + 1][1]],
          i * instStrideFloats
        );
      }
      const instVbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, instVbo);
      gl.bufferData(gl.ARRAY_BUFFER, instData, gl.STATIC_DRAW);

      /* ─── 6. VAO 설정 ─── */
      const vao = (gl.createVertexArray && gl.createVertexArray()) || null;
      if (vao) gl.bindVertexArray(vao);

      /* 정적 쿼드 attribute 0 (a_extrude) : divisor 0 */
      gl.bindBuffer(gl.ARRAY_BUFFER, quadVbo);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

      /* 인스턴스 attributes 1,2 : divisor 1 */
      gl.bindBuffer(gl.ARRAY_BUFFER, instVbo);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 0);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 16, 8);

      if (isWebGL2) {
        gl.vertexAttribDivisor(1, 1);
        gl.vertexAttribDivisor(2, 1);
      } else {
        instExt.vertexAttribDivisorANGLE(1, 1);
        instExt.vertexAttribDivisorANGLE(2, 1);
      }

      /* ─── 7. uniform & 그리기 ─── */
      const uViewSize = gl.getUniformLocation(prog, "u_viewSize");
      const uHalfWidth = gl.getUniformLocation(prog, "u_halfWidth");

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform2f(uViewSize, canvas.width, canvas.height);
      }
      window.addEventListener("resize", resize);
      resize();
      gl.uniform1f(uHalfWidth, 8.0); // 16px 두께

      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      const drawInstanced = (count) => {
        if (isWebGL2) {
          gl.drawElementsInstanced(
            gl.TRIANGLES,
            6,
            gl.UNSIGNED_SHORT,
            0,
            count
          );
        } else {
          instExt.drawElementsInstancedANGLE(
            gl.TRIANGLES,
            6,
            gl.UNSIGNED_SHORT,
            0,
            count
          );
        }
      };
      drawInstanced(segCount);
    </script>
  </body>
</html>
