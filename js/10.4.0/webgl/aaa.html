<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Minimal 2-vertex/segment polyline (gl_VertexID)</title>
<style>html,body,canvas{margin:0;width:100%;height:100%;background:#111}</style>
</head>
<body>
<canvas id="glc"></canvas>
<script>
/* ───────── 1. 원본 경로 ───────── */
const route = [
 [-122.48369693756104, 37.83381888486939],
 [-122.48348236083984, 37.83317489144141],
 [-122.48339653015138, 37.83270036637107],
 [-122.48356819152832, 37.832056363179625],
 [-122.48404026031496, 37.83114119107971],
 [-122.48404026031496, 37.83049717427869],
 [-122.48348236083984, 37.829920943955045],
 [-122.48356819152832, 37.82954808664175],
 [-122.48507022857666, 37.82944639795659],
 [-122.48610019683838, 37.82880236636284],
 [-122.48695850372314, 37.82931081282506],
 [-122.48700141906738, 37.83080223556934],
 [-122.48751640319824, 37.83168351665737],
 [-122.48803138732912, 37.832158048267786],
 [-122.48888969421387, 37.83297152392784],
 [-122.48987674713133, 37.83263257682617],
 [-122.49043464660643, 37.832937629287755],
 [-122.49125003814696, 37.832429207817725],
 [-122.49163627624512, 37.832564787218985],
 [-122.49223709106445, 37.83337825839438],
 [-122.49378204345702, 37.83368330777276],
];

/* ───────── 2. clip-space(-1~1) 정규화 ───────── */
const xs = route.map(p=>p[0]), ys = route.map(p=>p[1]);
const xmin = Math.min(...xs), xmax = Math.max(...xs);
const ymin = Math.min(...ys), ymax = Math.max(...ys);
const cx = x => ((x-xmin)/(xmax-xmin))*2-1;
const cy = y => ((y-ymin)/(ymax-ymin))*2-1;

/* ───────── 3. 2 정점/세그먼트 버퍼 ───────── */
const verts=[], idx=[];
for(let i=0;i<route.length-1;++i){
  const p0=[cx(route[i][0]),  cy(route[i][1])];
  const p1=[cx(route[i+1][0]),cy(route[i+1][1])];
  const dir=[p1[0]-p0[0], p1[1]-p0[1]];
  verts.push(...p0, ...dir);   // P0
  verts.push(...p1, ...dir);   // P1
  const b=i*2;
  idx.push(b,b+1,b,  b+1,b,b+1); // gl_VertexID 0-5
}

/* ───────── 4. WebGL2 컨텍스트 ───────── */
const gl=document.getElementById('glc').getContext('webgl2');
if(!gl){alert('WebGL2 not supported');}

/* ───────── 5. 셰이더 ───────── */
const vs=`#version 300 es
precision mediump float;
in vec2 a_pos;
in vec2 a_dir;
uniform vec2  u_viewPx;
uniform float u_halfW;

/* clip↔px 변환 */
vec2 px2clip(vec2 p){return p/u_viewPx*2.0-1.0;}
vec2 clip2px(vec2 c){return (c*0.5+0.5)*u_viewPx;}

void main(){
  int v = gl_VertexID & 3;               // ← 변경 ①
  float side = (v==0||v==2)?-1.0:1.0;
  float fwd  = (v<2)?0.0:1.0;

  vec2 base   = a_pos + a_dir*fwd;
  vec2 normal = normalize(vec2(-a_dir.y,a_dir.x));

  vec2 posPx  = clip2px(base) + normal*side*u_halfW;
  gl_Position = vec4(px2clip(posPx),0.0,1.0);
}`;

const fs=`#version 300 es
precision mediump float;
out vec4 fragColor;
void main(){ fragColor = vec4(0.1,0.8,1.0,1.0); }`;

/* 셰이더 컴파일/링크 */
function compile(src,type){
  const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(s);
  return s;
}
const prog=gl.createProgram();
gl.attachShader(prog,compile(vs,gl.VERTEX_SHADER));
gl.attachShader(prog,compile(fs,gl.FRAGMENT_SHADER));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog,gl.LINK_STATUS))throw gl.getProgramInfoLog(prog);
gl.useProgram(prog);

/* ───────── 6. VBO/IBO 업로드 ───────── */
const vbo=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(verts),gl.STATIC_DRAW);

const stride=4*4;                    // vec2+vec2
gl.enableVertexAttribArray(0);       // a_pos location 0
gl.vertexAttribPointer(0,2,gl.FLOAT,false,stride,0);
gl.enableVertexAttribArray(1);       // a_dir location 1
gl.vertexAttribPointer(1,2,gl.FLOAT,false,stride,8);

const ibo=gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ibo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(idx),gl.STATIC_DRAW);

/* ───────── 7. uniform & draw ───────── */
function resize(){
  gl.canvas.width=innerWidth;gl.canvas.height=innerHeight;
  gl.viewport(0,0,gl.canvas.width,gl.canvas.height);
  gl.uniform2f(gl.getUniformLocation(prog,'u_viewPx'),gl.canvas.width,gl.canvas.height);
}
function render(){
  gl.clearColor(0,0,0,1);gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform1f(gl.getUniformLocation(prog,'u_halfW'),7.0); // 14px
  gl.drawElements(gl.TRIANGLES,idx.length,gl.UNSIGNED_SHORT,0);
}
window.addEventListener('resize',()=>{resize();render();});
resize();render();
</script>
</body>
</html>
