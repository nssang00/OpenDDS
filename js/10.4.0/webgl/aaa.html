<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>Instanced Thick Polyline – WebGL 1/2 (attribute·varying 버전)</title>
<style>
  html,body,canvas{margin:0;width:100%;height:100%;background:#111;display:block}
</style>
</head>
<body>
<canvas id="gl"></canvas>

<script>
/* ───────────── 1. 컨텍스트 ───────────── */
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
if (!gl) { alert('WebGL 미지원'); throw 0; }

const isGL2  = gl instanceof WebGL2RenderingContext;
const instEx = isGL2 ? null : gl.getExtension('ANGLE_instanced_arrays');
if (!isGL2 && !instEx) {
  alert('ANGLE_instanced_arrays 확장 없음'); throw 0;
}

/* ───────────── 2. GLSL ES 1.00 셰이더 ───────────── */
const VS = `
precision mediump float;
attribute vec2 a_extrude;       /* 고정 쿼드: (-1/1,-1/1) */
attribute vec2 a_startPx;       /* 인스턴스: 세그먼트 시작 */
attribute vec2 a_endPx;         /* 인스턴스: 세그먼트 끝  */

uniform vec2  u_viewSize;       /* 캔버스 크기(px)  */
uniform float u_halfWidth;      /* 라인 반폭(px)    */

varying vec2 v_uv;              /* 필요 시 패턴용  */

void main() {
  vec2 t = normalize(a_endPx - a_startPx);
  vec2 n = vec2(-t.y, t.x);

  float s = (a_extrude.x + 1.0) * 0.5;        /* 0 or 1 */
  vec2 posPx = mix(a_startPx, a_endPx, s) +
               n * a_extrude.y * u_halfWidth;

  vec2 clip = posPx / u_viewSize * 2.0 - 1.0;
  gl_Position = vec4(clip, 0.0, 1.0);

  v_uv = a_extrude * 0.5 + 0.5;
}`;

const FS = `
precision mediump float;
varying vec2 v_uv;
void main() {
  gl_FragColor = vec4(0.08, 0.8, 1.0, 1.0);   /* 시안색 */
}`;

/* ───────────── 3. 프로그램 빌드 ───────────── */
function compile(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    throw gl.getShaderInfoLog(s);
  return s;
}
function link(vsSrc, fsSrc){
  const p = gl.createProgram();
  gl.attachShader(p, compile(gl.VERTEX_SHADER, vsSrc));
  gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fsSrc));

  /* WebGL 1: attribute 위치 고정 */
  gl.bindAttribLocation(p, 0, 'a_extrude');
  gl.bindAttribLocation(p, 1, 'a_startPx');
  gl.bindAttribLocation(p, 2, 'a_endPx');

  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS))
    throw gl.getProgramInfoLog(p);
  return p;
}
const prog = link(VS, FS);
gl.useProgram(prog);

/* ───────────── 4. 정적 쿼드 (4 정점) ───────────── */
const quad = new Float32Array([
  -1,-1,  -1,1,   1,-1,   1,1          /* a_extrude.xy */
]);
const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

/* 인덱스 버퍼 (ELEMENT_ARRAY_BUFFER) */
const indices = new Uint16Array([0,1,2, 1,3,2]);
const idxBuf  = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

/* ───────────── 5. 라인 경로 → 인스턴스 버퍼 ───────────── */
const route = [ [100,100],[300,120],[350,220],[200,300],[80,250] ];
const segCount = route.length - 1;
const instFloats = 4;                   /* start(x,y) + end(x,y) */
const instData = new Float32Array(segCount * instFloats);

for (let i=0;i<segCount;i++){
  instData.set([
    route[i][0],   route[i][1],
    route[i+1][0], route[i+1][1]
  ], i*instFloats);
}
const instBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, instBuf);
gl.bufferData(gl.ARRAY_BUFFER, instData, gl.STATIC_DRAW);

/* ───────────── 6. VAO + Attribute 설정 ───────────── */
const vao = (gl.createVertexArray && gl.createVertexArray()) || null;
if (vao) gl.bindVertexArray(vao);

/* 6-1. 고정 쿼드 */
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

/* 6-2. 인스턴스 데이터 */
gl.bindBuffer(gl.ARRAY_BUFFER, instBuf);
gl.enableVertexAttribArray(1);
gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 0);
gl.enableVertexAttribArray(2);
gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 16, 8);

if (isGL2){
  gl.vertexAttribDivisor(1,1);
  gl.vertexAttribDivisor(2,1);
}else{
  instEx.vertexAttribDivisorANGLE(1,1);
  instEx.vertexAttribDivisorANGLE(2,1);
}

/* ★ 반드시 VAO 바인딩 후 다시 연결 ★ */
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);

if (vao) gl.bindVertexArray(null);      /* 초기화 끝 */

/* ───────────── 7. Uniform & Draw ───────────── */
const uViewSize  = gl.getUniformLocation(prog,'u_viewSize');
const uHalfWidth = gl.getUniformLocation(prog,'u_halfWidth');

function resize(){
  canvas.width = window.innerWidth;
  canvas.height= window.innerHeight;
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.uniform2f(uViewSize, canvas.width, canvas.height);
}
window.addEventListener('resize',resize);
resize();
gl.uniform1f(uHalfWidth, 8.0);          /* 총 두께 16px */

/* ───────────── 8. 렌더 ───────────── */
gl.clearColor(0,0,0,1);
gl.clear(gl.COLOR_BUFFER_BIT);

const draw = () => {
  if (vao) gl.bindVertexArray(vao);     /* WebGL2에선 권장 */
  if (isGL2){
    gl.drawElementsInstanced(
      gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, segCount);
  }else{
    instEx.drawElementsInstancedANGLE(
      gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, segCount);
  }
  if (vao) gl.bindVertexArray(null);
};
draw();
</script>
</body>
</html>
