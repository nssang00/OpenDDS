// ====== Vertex shader ======
// ... [기존 코드 유지] ...

varying vec2  v_segmentStart;
varying vec2  v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_distance;
varying vec4  v_hitColor;
varying float v_segmentLength;  // 추가
varying vec2  v_tangent;        // 추가
varying vec2  v_normal;         // 추가
varying vec2  v_joinDirection;  // 추가

void main() {
  v_angleStart = a_joinAngles.x;
  v_angleEnd = a_joinAngles.y;

  vec2 segmentStartPx = worldToPx(a_segmentStart);
  vec2 segmentEndPx = worldToPx(a_segmentEnd);
  
  // 접선/법선 벡터 계산 (Vertex Shader에서 1회)
  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
  
  // 세그먼트 길이 계산
  v_segmentLength = length(segmentEndPx - segmentStartPx);
  
  // Join 방향 계산 (Vertex Shader에서 1회)
  float normalDir = a_position.y < 0.0 ? 1.0 : -1.0;
  float tangentDir = a_position.x < 0.0 ? 1.0 : -1.0;
  float angle = a_position.x < 0.0 ? v_angleStart : v_angleEnd;
  
  if (isCap(angle) || abs(cos(angle)) > 0.985) {
    v_joinDirection = normalPx * normalDir - tangentPx * tangentDir;
  } else {
    v_joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);
  }
  
  // 위치 계산
  vec2 positionPx = (a_position.x < 0.0) ? segmentStartPx : segmentEndPx;
  positionPx += v_joinDirection * (u_strokeWidth * 0.5 + 1.);
  gl_Position = pxToScreen(positionPx);

  // 프래그먼트 셰이더로 전달
  v_segmentStart = segmentStartPx;
  v_segmentEnd = segmentEndPx;
  v_tangent = tangentPx;
  v_normal = normalPx;
  v_distance = a_distance;
  v_hitColor = colorEncodeId(a_id);
}

// ====== Fragment shader ======
// ... [기존 코드 유지] ...

varying float v_segmentLength;  // 추가
varying vec2  v_tangent;        // 추가
varying vec2  v_normal;         // 추가
varying vec2  v_joinDirection;  // 추가

void main() {
  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;
  
  // Vertex Shader에서 계산된 값 재사용
  float segmentLength = v_segmentLength;
  vec2 segmentTangent = v_tangent;
  vec2 segmentNormal = v_normal;
  
  // 현재 길이 계산 (Vertex Shader로 이동 불가: 픽셀 위치 의존적)
  float currentLengthPx = dot(segmentTangent, currentPoint - v_segmentStart);
  currentLengthPx = clamp(currentLengthPx, 0.0, segmentLength) + v_distanceOffsetPx;
  
  // 거리 필드 계산
  float distToLine = segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, u_strokeWidth);
  
  // Cap/Join 계산 (Vertex Shader에서 미리 계산된 방향 사용)
  float distToStart = -1000.0;
  float distToEnd = -1000.0;
  
  if (currentLengthPx < u_strokeWidth * 0.5) {
    distToStart = dot(currentPoint - v_segmentStart, v_joinDirection);
  }
  
  if (segmentLength - currentLengthPx < u_strokeWidth * 0.5) {
    distToEnd = dot(currentPoint - v_segmentEnd, v_joinDirection);
  }
  
  // ... [나머지 코드 유지] ...
}

//////////////////////////////////////////











float scaleFactor = sampleSize.y / lineWidth;
float spacingScaled = (sampleSize.x + spacingPx) * scaleFactor;
float currentLengthScaled = currentLengthPx * scaleFactor;
float uCoordPx = mod(currentLengthScaled - startOffsetPx * scaleFactor, spacingScaled);
uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5); // sampleSize.x는 패턴 부분의 width
if (uCoordPx > sampleSize.x - 1.0) return vec4(0.0);

vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float startOffsetPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {
  float scaleFactor = sampleSize.y / lineWidth;
  float currentLengthScaled = currentLengthPx * scaleFactor;
  float spacingScaled = spacingPx * scaleFactor;
  float uCoordPx = mod(currentLengthScaled - startOffsetPx * scaleFactor, spacingScaled);
  uCoordPx = (uCoordPx / spacingScaled) * sampleSize.x;
  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;
  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;
  return texture2D(texture, texCoord);
}


vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float startOffsetPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {
    float scaleFactor        = sampleSize.y / lineWidth;
    float currentLengthScaled = currentLengthPx * scaleFactor;

    float spacingScaled = spacingPx * scaleFactor;
    if (spacingScaled < 1.0) {  
        spacingScaled = sampleSize.x; 
    }
    float uCoordPx = mod(currentLengthScaled - startOffsetPx * scaleFactor + sampleSize.x, spacingScaled);
    uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);
    if (uCoordPx > sampleSize.x - 1.0) return vec4(0.0);
    float vCoordPx = (0.5 - 0.5 * currentRadiusRatio) * sampleSize.y;
    vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;
    return texture2D(texture, texCoord);
}
