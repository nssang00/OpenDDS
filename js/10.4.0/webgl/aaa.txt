function makeViewProjectionMatrix(center, resolution, width, height) {
  // center: [x, y] (EPSG:3857 또는 원하는 좌표계)
  // resolution: m/px (줌에 따라 달라짐)
  // width, height: canvas 크기(px)
  const sx = 2 / (resolution * width);
  const sy = 2 / (resolution * height);
  return new Float32Array([
    sx,   0, 0, 0,
     0, -sy, 0, 0,
     0,   0, 1, 0,
    -center[0]*sx, center[1]*sy, 0, 1
  ]);
}

function makeOrthoProjectionMatrix(minX, minY, maxX, maxY, resolution) {
  // resolution=1이면 꽉 차게, resolution>1이면 축소, resolution<1이면 확대
  const sx = 2 / ((maxX - minX) * resolution);
  const sy = 2 / ((maxY - minY) * resolution);
  const tx = -(maxX + minX) / (maxX - minX);
  const ty = -(maxY + minY) / (maxY - minY);
  return new Float32Array([
    sx,  0, 0, 0,
     0, sy, 0, 0,
     0,  0, 1, 0,
    tx, ty, 0, 1
  ]);
}


// 해상도 테이블 예시 (줌별로 배열로 만들 수도 있음)
const resolutions = [
  156543.033928, 78271.516964, 39135.758482, 19567.879241,
  9783.9396205, 4891.96981025, 2445.98490513, 1222.99245256,
  611.496226281, 305.748113141, 152.87405657, 76.4370282852,
  38.2185141426, 19.1092570713, 9.55462853565, 4.77731426782,
  2.38865713391, 1.19432856696, 0.597164283478, 0.298582141739, 0.149291070869
];

// 화면 크기
const width = canvas.width;
const height = canvas.height;

// 지도 중심 (예시: EPSG:3857의 서울)
const center = [14135299, 4517287];

// 여러 해상도에서 행렬을 만들어보자!
[2, 7, 12, 17].forEach(zoom => {
  const resolution = resolutions[zoom];
  const matrix = makeViewProjectionMatrix(center, resolution, width, height);

  // 예시: WebGL uniform에 넘긴다고 가정
  gl.uniformMatrix4fv(gl.getUniformLocation(program, "u_projectionMatrix"), false, matrix);

  console.log(`zoom=${zoom}, resolution=${resolution}`);
  console.log(matrix);
  // → 실제로는 이 상태에서 draw 호출!
});
