float dashDistanceField(
  float distance, float radius, float capType, float lineWidth,
  float dashArray[8], int dashCount, float dashOffsetUniform
) {
  float totalDashLength = 0.0;
  for (int i = 0; i < 8; ++i) {
    if (i >= dashCount) break;
    totalDashLength += dashArray[i];
  }

  float minDist = 1e6;
  float dashOffset = 0.0;
  for (int i = 0; i < 8; i += 2) {
    if (i + 1 >= dashCount) break;
    float dashLength = dashArray[i];
    float d = getSingleDashDistance(
      distance + dashOffsetUniform, radius,
      dashOffset, dashLength, totalDashLength, capType, lineWidth
    );
    minDist = min(minDist, d);
    dashOffset += dashArray[i] + dashArray[i + 1];
  }
  return minDist;
}

///////////////

#define MAX_DASH 8

uniform float u_dashArray[MAX_DASH]; // [on, off, on, off, ...]
uniform int   u_dashCount;           // 실제 패턴 길이(짝수)
uniform float u_dashOffset;

// 기존 OpenLayers dash 필드 함수와 동일
float getSingleDashDistance(
  float distance, float radius, float dashOffset, float dashLength,
  float dashLengthTotal, float capType, float lineWidth
) {
  float localDistance = mod(distance, dashLengthTotal);
  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;
  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);

  if (capType == 5.0) { // square cap
    distanceSegment -= lineWidth * 0.5;
  } else if (capType == 6.0) { // round cap
    distanceSegment = min(
      distanceSegment,
      sqrt(distanceSegment * distanceSegment + radius * radius) - lineWidth * 0.5
    );
  }
  return distanceSegment;
}

// dashDistanceField는 dash 패턴 전체에서 getSingleDashDistance만 반복 호출 (최소값 리턴)
float dashDistanceField(
  float distance, float radius, float capType, float lineWidth
) {
  // dash 전체 길이 합
  float totalDashLength = 0.0;
  for(int i=0; i<MAX_DASH; ++i) {
    if(i >= u_dashCount) break;
    totalDashLength += u_dashArray[i];
  }

  float minDist = 1e6; // 충분히 큰 값
  float dashOffset = 0.0;
  for(int i=0; i<MAX_DASH; i+=2) {
    if(i+1 >= u_dashCount) break; // on/off 쌍
    float dashLength = u_dashArray[i];
    // offLen := u_dashArray[i+1]; // 필요시
    float d = getSingleDashDistance(
      distance + u_dashOffset, radius,
      dashOffset, dashLength, totalDashLength, capType, lineWidth
    );
    minDist = min(minDist, d);
    dashOffset += u_dashArray[i] + u_dashArray[i+1];
  }
  return minDist;
}

/////
const MAX_DASH = 8;
const dashArray = style.dashArray || [5, 3]; // 또는 원하는 패턴
const paddedDashArray = new Float32Array(MAX_DASH);
paddedDashArray.set(dashArray);
gl.uniform1fv(gl.getUniformLocation(program, "u_dashArray"), paddedDashArray);
gl.uniform1i(gl.getUniformLocation(program, "u_dashCount"), dashArray.length);
gl.uniform1f(gl.getUniformLocation(program, "u_dashOffset"), style.dashOffset || 0.0);

///////
float dashDist = dashDistanceField(currentLengthPx, currentRadiusPx, u_capType, v_width);
float alpha = smoothstep(0.5, -0.5, dashDist);
// ...
gl_FragColor = vec4(u_color, alpha * u_globalAlpha);


///////////
if ('stroke-line-dash' in style) {
  // 기본 getSingleDashDistance 함수는 그대로 유지
  context.functions['getSingleDashDistance'] =
    `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType, float lineWidth) {
    float localDistance = mod(distance, dashLengthTotal);
    float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;
    distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);
    if (capType == ${stringToGlsl('square')}) {
      distanceSegment -= lineWidth * 0.5;
    } else if (capType == ${stringToGlsl('round')}) {
      distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - lineWidth * 0.5);
    }
    return distanceSegment;
  }`;

  // 범용 dashDistanceField 함수 정의 (한 번만)
  if (!context.functions['dashDistanceField']) {
    context.functions['dashDistanceField'] =
      `float dashDistanceField(float distance, float radius, float capType, float lineWidth, float dashOffset) {
      const int MAX_DASH_SEGMENTS = 16; // 최대 dash 세그먼트 수
      float totalDashLength = 0.0;
      
      // 전체 dash 길이 계산
      for (int i = 0; i < MAX_DASH_SEGMENTS; i++) {
        if (i >= u_dashPatternLength) break;
        totalDashLength += u_dashPattern[i];
      }
      
      float minDistance = 1e10; // 매우 큰 값으로 초기화
      float currentOffset = dashOffset;
      
      // 각 dash 세그먼트에 대해 거리 계산 (dash는 짝수 인덱스)
      for (int i = 0; i < MAX_DASH_SEGMENTS; i += 2) {
        if (i >= u_dashPatternLength) break;
        
        float dashLength = u_dashPattern[i];
        float singleDashDist = getSingleDashDistance(
          distance, radius, currentOffset, dashLength, 
          totalDashLength, capType, lineWidth
        );
        minDistance = min(minDistance, singleDashDist);
        
        // 다음 오프셋 계산 (현재 dash + gap)
        if (i + 1 < u_dashPatternLength) {
          currentOffset += dashLength + u_dashPattern[i + 1];
        }
      }
      
      return minDistance;
    }`;
  }

  let dashPattern = style['stroke-line-dash'].map((v) =>
    expressionToGlsl(context, v, NumberType),
  );
  
  // 패턴이 홀수 길이면 짝수로 만들기
  if (dashPattern.length % 2 === 1) {
    dashPattern = [...dashPattern, ...dashPattern];
  }

  let offsetExpression = '0.';
  if ('stroke-line-dash-offset' in style) {
    offsetExpression = expressionToGlsl(
      context,
      style['stroke-line-dash-offset'],
      NumberType,
    );
  }

  // uniform 설정
  const maxDashSegments = 16; // GLSL에서 정의한 MAX_DASH_SEGMENTS와 동일
  const paddedPattern = [...dashPattern];
  
  // 패턴을 최대 길이까지 0으로 패딩
  while (paddedPattern.length < maxDashSegments) {
    paddedPattern.push('0.0');
  }

  // uniform 값들을 context에 추가
  context.uniforms = context.uniforms || {};
  context.uniforms['u_dashPattern'] = {
    type: 'float',
    size: maxDashSegments,
    value: paddedPattern
  };
  context.uniforms['u_dashPatternLength'] = {
    type: 'int',
    value: dashPattern.length
  };

  // 단일 범용 함수 호출
  builder.setStrokeDistanceFieldExpression(
    `dashDistanceField(currentLengthPx, currentRadiusPx, capType, v_width, ${offsetExpression})`
  );
}

// Uniform 설정을 위한 헬퍼 함수
function setupDashUniforms(gl, program, dashPattern, dashPatternLength) {
  const maxDashSegments = 16;
  const paddedPattern = new Float32Array(maxDashSegments);
  
  // 실제 패턴 값 설정
  for (let i = 0; i < Math.min(dashPattern.length, maxDashSegments); i++) {
    paddedPattern[i] = dashPattern[i];
  }
  
  // 나머지는 0으로 초기화 (이미 Float32Array 생성시 0으로 초기화됨)
  
  const dashPatternLocation = gl.getUniformLocation(program, 'u_dashPattern');
  const dashPatternLengthLocation = gl.getUniformLocation(program, 'u_dashPatternLength');
  
  gl.uniform1fv(dashPatternLocation, paddedPattern);
  gl.uniform1i(dashPatternLengthLocation, dashPatternLength);
}

//////////
////////
float dashDistanceField(float distance, float radius, float capType, float lineWidth, float dashOffset, float dashPattern[${dashPattern.length}], int dashPatternLength) {
  float totalDashLength = 0.0;
  for (int i = 0; i < dashPatternLength; ++i) {
    totalDashLength += dashPattern[i];
  }
  float result = 1e20; // Initialize to a large value
  float currentDashOffset = 0.0;
  for (int i = 0; i < dashPatternLength; i += 2) {
    result = min(result, getSingleDashDistance(distance, radius, currentDashOffset + dashOffset, dashPattern[i], totalDashLength, capType, lineWidth));
    if (i + 1 < dashPatternLength) {
      currentDashOffset += dashPattern[i] + dashPattern[i + 1];
    }
  }
  return result;
}`;
/////////////////////////////////
if ('stroke-line-dash' in style) {
  // 대시 패턴 처리 (홀수 길이면 복제하여 짝수로)
  let dashPattern = style['stroke-line-dash'].map(v => 
    expressionToGlsl(context, v, NumberType)
  );
  if (dashPattern.length % 2 === 1) {
    dashPattern = [...dashPattern, ...dashPattern];
  }

  // 대시 오프셋 표현식
  let offsetExpression = '0.';
  if ('stroke-line-dash-offset' in style) {
    offsetExpression = expressionToGlsl(
      context, 
      style['stroke-line-dash-offset'], 
      NumberType
    );
  }

  // 패턴을 유니폼으로 설정 (최대 10개)
  const MAX_DASHES = 10;
  const dashCount = Math.min(dashPattern.length, MAX_DASHES);
  const paddedPattern = [...dashPattern.slice(0, dashCount)];
  while (paddedPattern.length < MAX_DASHES) {
    paddedPattern.push('0.0');
  }

  // 유니폼 추가
  builder.addUniform('float', 'u_dashArray', `float[${MAX_DASHES}](${paddedPattern.join(',')})`);
  builder.addUniform('int', 'u_dashCount', `${dashCount}`);
  builder.addUniform('float', 'u_dashOffset', offsetExpression);

  // 범용 대시 거리 필드 함수 (GLSL)
  if (!context.functions['dashDistanceField']) {
    const squareCap = stringToGlsl('square');
    const roundCap = stringToGlsl('round');
    
    context.functions['dashDistanceField'] = `
float dashDistanceField(
  float distance, 
  float radius, 
  float capType, 
  float lineWidth,
  float dashArray[${MAX_DASHES}],
  int dashCount,
  float dashOffset
) {
  // 총 대시 길이 계산
  float totalLength = 0.0;
  for (int i = 0; i < dashCount; i++) {
    totalLength += dashArray[i];
  }
  if (totalLength <= 0.0) return 1e10;

  // 순환 거리 계산 (오프셋 적용)
  float cyclicDist = mod(distance + dashOffset, totalLength);
  if (cyclicDist < 0.0) cyclicDist += totalLength;
  
  // 최소 거리 계산
  float minDist = 1e10;
  float segStart = 0.0;
  
  for (int i = 0; i < dashCount; i += 2) {
    float dashLen = dashArray[i];
    float gapLen = dashArray[i+1];
    float segEnd = segStart + dashLen;
    
    // 대시 세그먼트 거리 계산
    float d = min(
      abs(cyclicDist - (segStart + dashLen * 0.5)) - dashLen * 0.5,
      totalLength - cyclicDist
    );
    
    // 캡 타입 보정
    if (capType == ${squareCap}) {
      d -= lineWidth * 0.5;
    } else if (capType == ${roundCap}) {
      d = min(d, sqrt(d * d + radius * radius) - lineWidth * 0.5);
    }
    
    minDist = min(minDist, d);
    segStart = segEnd + gapLen;
  }
  
  return minDist;
}`;
  }

  // 거리 필드 표현식 설정
  builder.setStrokeDistanceFieldExpression(
    `dashDistanceField(
      currentLengthPx,
      currentRadiusPx,
      capType,
      v_width,
      u_dashArray,
      u_dashCount,
      u_dashOffset
    )`
  );
}
