/**
 * 경‧위도 배열 → 인스턴스 버퍼 생성 (OpenLayers 방식 그대로)
 * ① 각도를 **픽셀 공간**에서 0 – 2π 로 계산  
 * ② angleTangentSum 을 “세그먼트 시작-전” 누계로 두 번(앞·뒤) 누적  
 * ③ a_distance 도 픽셀 길이로 누적
 */
function createInstanceData(coords) {
  /* ---------- (A) lon/lat → 픽셀 선형 변환 ---------- */
  const sx = canvas.width  / (maxLon - minLon);
  const sy = canvas.height / (maxLat - minLat);
  const tx = -minLon * sx;
  const ty = -minLat * sy;
  const toPx = ([lon, lat]) => [lon * sx + tx, lat * sy + ty];

  /* ---------- (B) OpenLayers 원본 각도 함수 ---------- */
  function angleBetweenPx(p0, pA, pB) {
    const lenA = Math.hypot(pA[0] - p0[0], pA[1] - p0[1]);
    const lenB = Math.hypot(pB[0] - p0[0], pB[1] - p0[1]);
    if (lenA === 0 || lenB === 0) return -1.0;          // cap sentinel
    const tAx = (pA[0] - p0[0]) / lenA, tAy = (pA[1] - p0[1]) / lenA;
    const tBx = (pB[0] - p0[0]) / lenB, tBy = (pB[1] - p0[1]) / lenB;
    const ang  = Math.acos(Math.max(-1, Math.min(1, tAx * tBx + tAy * tBy)));
    const cross = tAx * tBy - tAy * tBx;
    return cross < 0 ? 2 * Math.PI - ang : ang;         // 0 … 2π
  }

  const instanceCount = coords.length - 1;
  const instanceData  = new Float32Array((instanceCount * STRIDE) / 4);

  let distPx = 0;           // 픽셀 누적길이
  let angleTangentSum = 0;  // 누적 tan((π-|θ|)/2)

  for (let i = 0; i < instanceCount; i++) {
    const idx = (i * STRIDE) / 4;

    const p0 = coords[i];
    const p1 = coords[i + 1];
    const p0px = toPx(p0);
    const p1px = toPx(p1);

    const prev = i              ? coords[i - 1] : p0;
    const next = i < instanceCount - 1 ? coords[i + 2] : p1;

    const angle0 = i              ? angleBetweenPx(p0px, p1px, toPx(prev)) : -1.0;
    const angle1 = i < instanceCount - 1 ? angleBetweenPx(p1px, p0px, toPx(next)) : -1.0;

    /* ---------- (C) attribute 기록 ---------- */
    instanceData.set(
      [
        p0[0], p0[1],            // a_segmentStart
        p1[0], p1[1],            // a_segmentEnd
        distPx,                  // a_distance  (픽셀)
        angle0, angle1,          // a_joinAngles
        i,                       // a_id
        angleTangentSum,         // a_angleTangentSum (세그먼트 시작 시점)
      ],
      idx
    );

    /* ---------- (D) angleTangentSum 누적 (OL 공식) ---------- */
    if (i && Math.abs(Math.cos(angle0)) <= 0.98) {
      angleTangentSum += Math.tan((angle0 - Math.PI) / 2);        // 시작쪽
    }
    if (i < instanceCount - 1 && Math.abs(Math.cos(angle1)) <= 0.98) {
      angleTangentSum += Math.tan((Math.PI - angle1) / 2);        // 끝쪽
    }

    /* ---------- (E) 픽셀 길이 누적 ---------- */
    distPx += Math.hypot(p1px[0] - p0px[0], p1px[1] - p0px[1]);
  }

  return { instanceData, instanceCount };
}
