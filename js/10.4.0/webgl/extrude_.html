<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Polyline – GPU extrude</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html, body, canvas { margin: 0; height: 100%; width: 100%; display: block; background:#111; }
      .ui { position:absolute; top:10px; left:10px; color:#eee; font:14px/1 sans-serif; }
    </style>
  </head>
  <body>
    <canvas id="glcanvas"></canvas>
    <div class="ui">
      <label>Width [m] 
        <input id="wSlider" type="range" min="2" max="60" value="24"/>
        <span id="wVal">24</span>
      </label>
    </div>

    <script>
/* ───────── 1. 샘플 경로 ───────── */
const route = [
  [-122.48369693756104, 37.83381888486939],
  [-122.48348236083984, 37.83317489144141],
  [-122.48339653015138, 37.83270036637107],
  [-122.48356819152832, 37.832056363179625],
  [-122.48404026031496, 37.83114119107971],
  [-122.48404026031496, 37.83049717427869],
  [-122.48348236083984, 37.829920943955045],
  [-122.48356819152832, 37.82954808664175],
  [-122.48507022857666, 37.82944639795659],
  [-122.48610019683838, 37.82880236636284],
  [-122.48695850372314, 37.82931081282506],
  [-122.48700141906738, 37.83080223556934],
  [-122.48751640319824, 37.83168351665737],
  [-122.48803138732912, 37.832158048267786],
  [-122.48888969421387, 37.83297152392784],
  [-122.48987674713133, 37.83263257682617],
  [-122.49043464660643, 37.832937629287755],
  [-122.49125003814696, 37.832429207817725],
  [-122.49163627624512, 37.832564787218985],
  [-122.49223709106445, 37.83337825839438],
  [-122.49378204345702, 37.83368330777276],
];

/* ───────── 2. 투영·벡터 유틸 ───────── */
const R = 6378137;
const rad = d => d * Math.PI / 180;
const toXY = ([lng,lat], baseLat)=>
  [rad(lng)*R*Math.cos(rad(baseLat)), rad(lat)*R];     // WebMercator 근사
const sub = (a,b)=>[a[0]-b[0], a[1]-b[1]];
const add = (a,b)=>[a[0]+b[0], a[1]+b[1]];
const scale = (v,s)=>[v[0]*s, v[1]*s];
const len = v=>Math.hypot(v[0],v[1]);
const norm = v=>{ const l=len(v); return [v[0]/l,v[1]/l]; };
const perp = v=>[-v[1], v[0]];
const dot = (a,b)=>a[0]*b[0]+a[1]*b[1];

/* ───────── 3. 버퍼 생성 (extrude 방식) ───────── */
function buildBuffers(lngLat) {
  const baseLat = lngLat[0][1];
  const P = lngLat.map(c=>toXY(c,baseLat));            // 월드 좌표

  // 세그먼트 방향·법선
  const dir=[], normL=[];
  for(let i=0;i<P.length-1;i++){
    const d = norm(sub(P[i+1],P[i]));
    dir.push(d);
    normL.push(perp(d));
  }

  const v=[], idx=[];
  for(let i=0;i<P.length;i++){
    const nPrev = i>0               ? normL[i-1]         : normL[0];
    const nNext = i<P.length-1      ? normL[i]           : normL[normL.length-1];
    let e = add(nPrev,nNext);
    if(len(e)<1e-6) e=nPrev;                       // 180°
    const eHat = norm(e);                          // 단위 bisector

    // 왼쪽(+), 오른쪽(-) 두 정점
    v.push(...P[i],  ...eHat);    // left  (extrude +1  사용 예정)
    v.push(...P[i],  ...scale(eHat,-1)); // right (extrude -1)
  }

  for(let i=0;i<P.length-1;i++){
    const a=i*2, b=a+1, c=a+2, d=a+3;
    idx.push(a,b,c, b,d,c);
  }

  // world → clip 변환 계수 (2차원 only)
  const xs=v.filter((_,i)=>i%4===0), ys=v.filter((_,i)=>i%4===1);
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);
  const scaleX = 2/(maxX-minX),  scaleY = 2/(maxY-minY);
  const translateX = -minX,      translateY = -minY;

  return {
    vertices:new Float32Array(v),                 // [x,y,ex,ey] …
    indices:new Uint16Array(idx),
    scale:[scaleX,scaleY],
    translate:[translateX,translateY]
  };
}

/* ───────── 4. WebGL 초기화 ───────── */
const canvas=document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');
if(!gl) alert('WebGL not supported');

const vsSrc=`
attribute vec2 a_pos;
attribute vec2 a_extrude;
uniform vec2 u_scale;
uniform vec2 u_translate;
uniform float u_halfWidth;       // world 좌표 기준
void main(){
  vec2 world = a_pos + a_extrude * u_halfWidth;
  vec2 clip  = vec2(
      (world.x + u_translate.x) * u_scale.x - 1.0,
      (world.y + u_translate.y) * u_scale.y - 1.0
  );
  gl_Position = vec4(clip,0.0,1.0);
}`;
const fsSrc=`
precision mediump float;
void main(){ gl_FragColor = vec4(1.0,0.25,0.25,1.0); }`;

function compile(type,src){
  const s=gl.createShader(type);
  gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s));
  return s;
}
const prog=gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,vsSrc));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fsSrc));
gl.linkProgram(prog); gl.useProgram(prog);

const loc = {
  a_pos      : gl.getAttribLocation(prog,'a_pos'),
  a_extrude  : gl.getAttribLocation(prog,'a_extrude'),
  u_scale    : gl.getUniformLocation(prog,'u_scale'),
  u_translate: gl.getUniformLocation(prog,'u_translate'),
  u_halfWidth: gl.getUniformLocation(prog,'u_halfWidth')
};

/* ───────── 5. 버퍼 업로드 ───────── */
const {vertices,indices,scale,translate}=buildBuffers(route);

const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);

const ebo = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ebo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,indices,gl.STATIC_DRAW);

const stride = 4*4; // 4 floats
gl.enableVertexAttribArray(loc.a_pos);
gl.vertexAttribPointer(loc.a_pos,2,gl.FLOAT,false,stride,0);
gl.enableVertexAttribArray(loc.a_extrude);
gl.vertexAttribPointer(loc.a_extrude,2,gl.FLOAT,false,stride,8); // offset 2 floats

gl.uniform2fv(loc.u_scale,scale);
gl.uniform2fv(loc.u_translate,translate);

/* ───────── 6. 렌더 & 리사이즈 ───────── */
function resize(){
  canvas.width = canvas.clientWidth;
  canvas.height= canvas.clientHeight;
  gl.viewport(0,0,canvas.width,canvas.height);
  draw();
}
window.addEventListener('resize',resize);
resize();

function draw(){
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawElements(gl.TRIANGLES,indices.length,gl.UNSIGNED_SHORT,0);
}

/* ───────── 7. 두께 슬라이더 ───────── */
const wSlider=document.getElementById('wSlider');
const wVal   =document.getElementById('wVal');
function updateWidth(){
  const w=parseFloat(wSlider.value);
  wVal.textContent=w;
  gl.uniform1f(loc.u_halfWidth, w/2);
  draw();
}
wSlider.addEventListener('input',updateWidth);
updateWidth();
    </script>
  </body>
</html>
