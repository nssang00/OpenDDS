<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Polyline – GPU extrude</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body, canvas { margin:0; height:100%; width:100%; display:block; background:#111; }
    .ui { position:absolute; top:10px; left:10px; color:#eee; font:14px/1 sans-serif; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div class="ui">
  <label>Width [m]
    <input id="wSlider" type="range" min="2" max="60" value="24">
    <span id="wVal">24</span>
  </label>
</div>

<script>
/* ───────── 1. sample path ───────── */
const route = [ /* … same coords … */ ];

/* ───────── 2. projection / vector utils ───────── */
const R = 6378137;
const rad  = d => d * Math.PI / 180;
const toXY = ([lng,lat], baseLat) => [rad(lng)*R*Math.cos(rad(baseLat)), rad(lat)*R]; // WebMercator approx
const sub  = (a,b)=>[a[0]-b[0], a[1]-b[1]];
const add  = (a,b)=>[a[0]+b[0], a[1]+b[1]];
const vecScale = (v,s)=>[v[0]*s, v[1]*s];             // renamed
const len  = v=>Math.hypot(v[0],v[1]);
const norm = v=>{ const l=len(v); return [v[0]/l, v[1]/l]; };
const perp = v=>[-v[1], v[0]];
const dot  = (a,b)=>a[0]*b[0]+a[1]*b[1];

/* ───────── 3. buffer builder (extrude) ───────── */
function buildBuffers(lngLat){
  const baseLat = lngLat[0][1];
  const P = lngLat.map(c=>toXY(c, baseLat));          // world coords

  // segment directions & left normals
  const dir=[], normL=[];
  for(let i=0;i<P.length-1;i++){
    const d=norm(sub(P[i+1],P[i]));
    dir.push(d); normL.push(perp(d));
  }

  const v=[], idx=[];
  for(let i=0;i<P.length;i++){
    const nPrev = i>0           ? normL[i-1]          : normL[0];
    const nNext = i<P.length-1  ? normL[i]            : normL[normL.length-1];
    let  e = add(nPrev, nNext);
    if(len(e)<1e-6) e=nPrev;                          // straight (180°)
    const eHat = norm(e);                             // bisector

    v.push(...P[i], ...eHat);                         // left  (+1)
    v.push(...P[i], ...vecScale(eHat,-1));            // right (-1)
  }

  for(let i=0;i<P.length-1;i++){
    const a=i*2, b=a+1, c=a+2, d=a+3;
    idx.push(a,b,c, b,d,c);
  }

  // 2-D world→clip transform
  const xs=v.filter((_,i)=>i%4===0), ys=v.filter((_,i)=>i%4===1);
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);
  const scaleX=2/(maxX-minX), scaleY=2/(maxY-minY);

  return {
    vertices : new Float32Array(v),       // [x,y,ex,ey] …
    indices  : new Uint16Array(idx),
    scale    : [scaleX, scaleY],
    translate: [-minX, -minY]
  };
}

/* ───────── 4. WebGL init ───────── */
const canvas=document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');
if(!gl) alert('WebGL not supported');

const vsSrc=`
attribute vec2 a_pos;
attribute vec2 a_extrude;
uniform vec2  u_scale;
uniform vec2  u_translate;
uniform float u_halfWidth;
void main(){
  vec2 world = a_pos + a_extrude * u_halfWidth;
  vec2 clip  = vec2(
      (world.x + u_translate.x) * u_scale.x - 1.0,
      (world.y + u_translate.y) * u_scale.y - 1.0
  );
  gl_Position = vec4(clip, 0.0, 1.0);
}`;
const fsSrc=`precision mediump float; void main(){ gl_FragColor = vec4(1.0,0.25,0.25,1.0); }`;

function compile(type,src){
  const s=gl.createShader(type);
  gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s));
  return s;
}
const prog=gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,vsSrc));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fsSrc));
gl.linkProgram(prog); gl.useProgram(prog);

const loc={
  a_pos      : gl.getAttribLocation(prog,'a_pos'),
  a_extrude  : gl.getAttribLocation(prog,'a_extrude'),
  u_scale    : gl.getUniformLocation(prog,'u_scale'),
  u_translate: gl.getUniformLocation(prog,'u_translate'),
  u_halfWidth: gl.getUniformLocation(prog,'u_halfWidth')
};

/* ───────── 5. upload buffers ───────── */
const {vertices, indices, scale, translate} = buildBuffers(route);

const vbo=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);

const ebo=gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ebo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,indices,gl.STATIC_DRAW);

const stride=4*4;
gl.enableVertexAttribArray(loc.a_pos);
gl.vertexAttribPointer(loc.a_pos,2,gl.FLOAT,false,stride,0);
gl.enableVertexAttribArray(loc.a_extrude);
gl.vertexAttribPointer(loc.a_extrude,2,gl.FLOAT,false,stride,8);

gl.uniform2fv(loc.u_scale,scale);
gl.uniform2fv(loc.u_translate,translate);

/* ───────── 6. render & resize ───────── */
function resize(){
  canvas.width = canvas.clientWidth;
  canvas.height= canvas.clientHeight;
  gl.viewport(0,0,canvas.width,canvas.height);
  draw();
}
window.addEventListener('resize', resize);
resize();

function draw(){
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
}

/* ───────── 7. width slider ───────── */
const wSlider=document.getElementById('wSlider');
const wVal   =document.getElementById('wVal');
function updateWidth(){
  const w=parseFloat(wSlider.value);
  wVal.textContent=w;
  gl.uniform1f(loc.u_halfWidth, w*0.5);
  draw();
}
wSlider.addEventListener('input',updateWidth);
updateWidth();
</script>
</body>
</html>
