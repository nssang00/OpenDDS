<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GPU 버퍼 캐싱 성능 개선</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      color: #fff;
      min-height: 100vh;
      overflow: hidden;
      position: relative;
    }
    
    .container {
      display: flex;
      min-height: 100vh;
      position: relative;
    }
    
    header {
      background: rgba(0, 0, 0, 0.7);
      padding: 1.5rem;
      text-align: center;
      border-bottom: 3px solid #00ccff;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
      color: #00ccff;
      text-shadow: 0 0 10px rgba(0, 204, 255, 0.7);
    }
    
    .subtitle {
      font-size: 1.2rem;
      opacity: 0.9;
      max-width: 800px;
      margin: 0 auto;
    }
    
    .content {
      display: flex;
      flex: 1;
      padding: 2rem;
    }
    
    .canvas-container {
      flex: 1;
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(0, 204, 255, 0.3);
      background: rgba(10, 15, 30, 0.6);
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    
    .controls {
      width: 320px;
      background: rgba(0, 0, 0, 0.7);
      padding: 1.5rem;
      border-radius: 12px;
      margin-left: 2rem;
      border: 1px solid rgba(0, 204, 255, 0.3);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }
    
    .controls h2 {
      color: #00ccff;
      margin-bottom: 1.5rem;
      text-align: center;
      font-size: 1.8rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid rgba(0, 204, 255, 0.3);
    }
    
    .control-group {
      margin-bottom: 1.5rem;
    }
    
    .control-group h3 {
      margin-bottom: 0.8rem;
      color: #4CAF50;
      display: flex;
      align-items: center;
    }
    
    .control-group h3 i {
      margin-right: 10px;
      color: #00ccff;
    }
    
    .slider-container {
      background: rgba(30, 40, 80, 0.4);
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #a0d2ff;
    }
    
    input[type="range"] {
      width: 100%;
      height: 10px;
      background: rgba(100, 150, 255, 0.2);
      border-radius: 5px;
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #00ccff;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 204, 255, 0.7);
    }
    
    .value-display {
      display: flex;
      justify-content: space-between;
      margin-top: 5px;
      color: #00ccff;
      font-weight: 500;
    }
    
    button {
      background: linear-gradient(135deg, #00b09b, #00ccff);
      color: white;
      border: none;
      padding: 12px 20px;
      font-size: 1rem;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      width: 100%;
      margin: 8px 0;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    #clearLines {
      background: linear-gradient(135deg, #ff416c, #ff4b2b);
    }
    
    .stats {
      background: rgba(30, 40, 80, 0.4);
      padding: 1.2rem;
      border-radius: 8px;
      margin-top: 1.5rem;
      border: 1px solid rgba(0, 204, 255, 0.2);
    }
    
    .stats h3 {
      text-align: center;
      margin-bottom: 1rem;
      color: #00ccff;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(100, 150, 255, 0.2);
    }
    
    .stat-row:last-child {
      border-bottom: none;
    }
    
    .stat-value {
      color: #4CAF50;
      font-weight: 600;
    }
    
    footer {
      text-align: center;
      padding: 1.5rem;
      background: rgba(0, 0, 0, 0.7);
      border-top: 2px solid rgba(0, 204, 255, 0.3);
      margin-top: auto;
    }
    
    .info {
      display: flex;
      justify-content: space-around;
      max-width: 1000px;
      margin: 0 auto;
    }
    
    .info-box {
      background: rgba(30, 40, 80, 0.4);
      padding: 1rem;
      border-radius: 8px;
      width: 30%;
    }
    
    .info-box h3 {
      color: #00ccff;
      margin-bottom: 0.5rem;
    }
    
    /* 애니메이션 효과 */
    @keyframes pulse {
      0% { box-shadow: 0 0 5px rgba(0, 204, 255, 0.5); }
      50% { box-shadow: 0 0 20px rgba(0, 204, 255, 0.8); }
      100% { box-shadow: 0 0 5px rgba(0, 204, 255, 0.5); }
    }
    
    .highlight {
      animation: pulse 2s infinite;
    }
    
    /* 반응형 디자인 */
    @media (max-width: 1100px) {
      .content {
        flex-direction: column;
      }
      
      .controls {
        width: 100%;
        margin-left: 0;
        margin-top: 2rem;
      }
      
      .info {
        flex-direction: column;
        align-items: center;
      }
      
      .info-box {
        width: 100%;
        margin-bottom: 1rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>WebGL 라인 렌더링 성능 개선</h1>
    <p class="subtitle">GPU 버퍼 캐싱을 활용한 고성능 라인 렌더링 시스템 - WeakMap을 사용한 효율적인 메모리 관리</p>
  </header>
  
  <div class="container">
    <div class="content">
      <div class="canvas-container highlight">
        <canvas id="glcanvas" width="1024" height="768"></canvas>
      </div>
      
      <div class="controls">
        <h2>렌더링 제어</h2>
        
        <div class="control-group">
          <h3><i>●</i> 라인 속성</h3>
          <div class="slider-container">
            <label for="lineWidth">라인 두께: <span id="widthValue">12</span>px</label>
            <input type="range" id="lineWidth" min="1" max="30" value="12">
          </div>
          
          <div class="slider-container">
            <label for="lineOffset">라인 오프셋: <span id="offsetValue">-5</span>px</label>
            <input type="range" id="lineOffset" min="-20" max="20" value="-5">
          </div>
        </div>
        
        <div class="control-group">
          <h3><i>●</i> 라인 스타일</h3>
          <button id="solidStyle">실선 (Solid)</button>
          <button id="dashedStyle">점선 (Dashed)</button>
          <button id="patternStyle">패턴 (Pattern)</button>
        </div>
        
        <div class="control-group">
          <h3><i>●</i> 라인 관리</h3>
          <button id="addLine">새 라인 추가</button>
          <button id="clearLines">모든 라인 제거</button>
        </div>
        
        <div class="stats">
          <h3>성능 통계</h3>
          <div class="stat-row">
            <span>캐시된 버퍼:</span>
            <span class="stat-value" id="bufferCount">0</span>
          </div>
          <div class="stat-row">
            <span>렌더링된 라인:</span>
            <span class="stat-value" id="lineCount">0</span>
          </div>
          <div class="stat-row">
            <span>FPS:</span>
            <span class="stat-value" id="fpsValue">0</span>
          </div>
          <div class="stat-row">
            <span>메모리 사용량:</span>
            <span class="stat-value" id="memoryUsage">0</span> MB
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <footer>
    <div class="info">
      <div class="info-box">
        <h3>GPU 버퍼 캐싱</h3>
        <p>WeakMap을 사용하여 좌표 데이터를 GPU 버퍼에 캐싱함으로써 동일한 데이터의 재사용 시 성능을 향상시킵니다.</p>
      </div>
      <div class="info-box">
        <h3>인스턴스 렌더링</h3>
        <p>WebGL의 인스턴스 렌더링 기능을 활용하여 수천 개의 라인을 고성능으로 렌더링합니다.</p>
      </div>
      <div class="info-box">
        <h3>실시간 제어</h3>
        <p>라인의 두께, 오프셋, 스타일 등을 실시간으로 변경하며 결과를 확인할 수 있습니다.</p>
      </div>
    </div>
  </footer>

  <script>
    // GPU 버퍼 캐시 (WeakMap 사용)
    const bufferCache = new WeakMap();
    let bufferInfoCount = 0;
    
    // 캐시에서 버퍼 가져오기 또는 생성
    function getOrCreateBuffer(coords) {
      // 객체 자체를 키로 사용
      if (bufferCache.has(coords)) {
        return bufferCache.get(coords);
      }
      
      const { instanceData, instanceCount } = createInstanceData(coords);
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, instanceData, gl.STATIC_DRAW);
      
      const bufferInfo = { 
        buffer, 
        instanceCount, 
        size: instanceData.byteLength 
      };
      
      bufferCache.set(coords, bufferInfo);
      bufferInfoCount++;
      
      updateStats();
      
      return bufferInfo;
    }

    // 통계 업데이트
    function updateStats() {
      document.getElementById('bufferCount').textContent = bufferInfoCount;
      
      // 메모리 사용량 계산 (대략적)
      let memory = 0;
      // WeakMap을 직접 순회할 수 없으므로 추적을 위한 별도 메커니즘 필요
      // 실제 프로덕션에서는 더 정교한 메모리 추적 필요
      memory = bufferInfoCount * 500; // 예시 값
      document.getElementById('memoryUsage').textContent = (memory / 1024).toFixed(2);
    }

    // 캔버스 및 WebGL 컨텍스트 설정
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl");
    const ext = gl.getExtension("ANGLE_instanced_arrays");
    if (!ext) throw "ANGLE_instanced_arrays 미지원";

    // ====== Vertex shader ======
    const vertexShaderSource = `
      // ... vertex shader 코드 (위와 동일) ...
    `;

    // ====== Fragment shader ======
    const fragmentShaderSource = `
      // ... fragment shader 코드 (위와 동일) ...
    `;

    // 쉐이더 컴파일 및 프로그램 생성 함수
    function compileShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw gl.getShaderInfoLog(shader);
      }
      return shader;
    }

    function getProgram(fragmentShaderSource, vertexShaderSource) {
      const program = gl.createProgram();
      gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vertexShaderSource));
      gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource));
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw gl.getShaderInfoLog(program);
      }
      return program;
    }
    
    const instanceAttributes = [
      { name: "a_segmentStart", size: 2 },
      { name: "a_segmentEnd",   size: 2 },
      { name: "a_distance",     size: 1 },
      { name: "a_joinAngles",   size: 2 },
      { name: "a_id",           size: 1 },
      { name: "a_angleTangentSum", size: 1 }
    ];

    // 기본 좌표 데이터
    const baseCoordinates = [
      [-122.48369693756104, 37.83381888486939],
      [-122.48348236083984, 37.83317489144141],
      [-122.48339653015138, 37.83270036637107],
      [-122.48356819152832, 37.832056363179625],
      [-122.48404026031496, 37.83114119107971],
      [-122.48404026031496, 37.83049717427869],
      [-122.48348236083984, 37.829920943955045],
      [-122.48356819152832, 37.82954808664175],
      [-122.48507022857666, 37.82944639795659],
      [-122.48610019683838, 37.82880236636284],
      [-122.48695850372314, 37.82931081282506],
      [-122.48700141906738, 37.83080223556934],
      [-122.48751640319824, 37.83168351665737],
      [-122.48803138732912, 37.832158048267786],
      [-122.48888969421387, 37.83297152392784],
      [-122.48987674713133, 37.83263257682617],
      [-122.49043464660643, 37.832937629287755],
      [-122.49125003814696, 37.832429207817725],
      [-122.49163627624512, 37.832564787218985],
      [-122.49223709106445, 37.83337825839438],
      [-122.49378204345702, 37.83368330777276]
    ];

    // 랜덤 좌표 생성
    function generateRandomCoordinates(base, count = 10, offset = 0.01) {
      const coords = [];
      for (let i = 0; i < count; i++) {
        const randomOffset = [
          (Math.random() - 0.5) * offset,
          (Math.random() - 0.5) * offset
        ];
        coords.push([
          base[i % base.length][0] + randomOffset[0],
          base[i % base.length][1] + randomOffset[1]
        ]);
      }
      return coords;
    }

    // 인스턴스 데이터 생성
    function createInstanceData(coords) {
      const applyTransform = ([lon, lat]) => [lon, lat];

      function angleBetween(p0, pA, pB) {
        const lenA = Math.sqrt(
          (pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1]),
        );
        const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];
        const orthoA = [-tangentA[1], tangentA[0]];
        const lenB = Math.sqrt(
          (pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1]),
        );
        const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];
      
        const angle =
          lenA === 0 || lenB === 0
            ? 0
            : Math.acos(
                Math.min(Math.max(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1), 1),
              );
        const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;
        return !isClockwise ? Math.PI * 2 - angle : angle;
      }

      const instanceCount = coords.length - 1;
      const instanceData = [];

      let distances = 0; 
      let angleTangentSum = 0;

      for (let i = 0; i < instanceCount; i++) {
        const p0 = coords[i];
        const p1 = coords[i + 1];
        const p0world = applyTransform(p0);
        const p1world = applyTransform(p1);

        const pB = i > 0 ? coords[i - 1] : p0;
        const pBworld = applyTransform(pB);
        const angle0 = i > 0 ? angleBetween(p0world, p1world, pBworld) : -1.0;

        const pA = i < instanceCount - 1 ? coords[i + 2] : p1;
        const pAworld = applyTransform(pA);        
        const angle1 = i < instanceCount - 1 ? angleBetween(p1world, p0world, pAworld) : -1.0;

        instanceData.push(
          p0[0], p0[1],            // a_segmentStart
          p1[0], p1[1],            // a_segmentEnd
          distances,               // a_distance
          angle0, angle1,          // a_joinAngles
          i,                       // a_id
          angleTangentSum          // a_angleTangentSum 
        );

        if (i > 0 && Math.abs(Math.cos(angle0)) <= 0.98) {
          angleTangentSum += Math.tan((angle0 - Math.PI) / 2);
        }
        if (i < instanceCount - 1 && Math.abs(Math.cos(angle1)) <= 0.98) {
          angleTangentSum += Math.tan((Math.PI - angle1) / 2); 
        }
        distances += Math.hypot(p1world[0] - p0world[0], p1world[1] - p0world[1]);
      }

      return {
        instanceData: new Float32Array(instanceData),
        instanceCount
      };
    }
 
    // 어트리뷰트 바인딩
    function bindAttrib(name, size, stride, offset, div) {
      const location = gl.getAttribLocation(program, name);
      gl.enableVertexAttribArray(location);
      gl.vertexAttribPointer(location, size, gl.FLOAT, false, stride, offset);
      ext.vertexAttribDivisorANGLE(location, div);
    }
    
    function bindInstanceAttributes(attribs, divisor = 1) {
      const stride = attribs.reduce((sum, a) => sum + a.size, 0) * 4;
      let offset = 0;
      for (const attr of attribs) {
        bindAttrib(attr.name, attr.size, stride, offset, divisor);
        offset += attr.size * 4;
      }
    }

    // 유니폼 설정
    function setLineUniforms(style) {
      gl.uniformMatrix4fv(gl.getUniformLocation(program, "u_projectionMatrix"), false, createProjectionMatrix(style.scale, style.rotation));
      gl.uniform2f(gl.getUniformLocation(program, "u_viewportSizePx"), canvas.width, canvas.height);
      gl.uniform1f(gl.getUniformLocation(program, "u_pixelRatio"), window.devicePixelRatio || 1);
      gl.uniform1f(gl.getUniformLocation(program, "u_globalAlpha"), 1.0);
      gl.uniform1f(gl.getUniformLocation(program, "u_depth"), 0.0);
      gl.uniform1f(gl.getUniformLocation(program, "u_resolution"), 1.0);

      gl.uniform4f(gl.getUniformLocation(program, "u_strokeColor"), ...style.strokeColor);
      gl.uniform1f(gl.getUniformLocation(program, "u_strokeWidth"), style.strokeWidth);    
      gl.uniform1f(gl.getUniformLocation(program, "u_strokeOffset"), style.strokeOffset);
      gl.uniform1f(gl.getUniformLocation(program, "u_strokeCap"), style.strokeCap);
      gl.uniform1f(gl.getUniformLocation(program, "u_strokeJoin"), style.strokeJoin);
      gl.uniform1f(gl.getUniformLocation(program, "u_strokeMiterLimit"), style.strokeMiterLimit);
      
      gl.uniform1i(gl.getUniformLocation(program, "u_useStrokePattern"), style.useStrokePattern ? 1 : 0);    
    }

    // 투영 행렬 생성
    function makeOrthoProjectionMatrix(centerX, centerY, bboxWidth, bboxHeight, viewWidth, viewHeight, scale = 1, rotation = 0) {
      const baseRes = Math.max(bboxWidth / viewWidth, bboxHeight / viewHeight);
      const sx = 2 / (viewWidth * baseRes * scale);
      const sy = 2 / (viewHeight * baseRes * scale);

      const cosR = Math.cos(rotation);
      const sinR = Math.sin(rotation);

      return new Float32Array([
        sx * cosR,  sx * sinR, 0, 0,
      -sy * sinR,  sy * cosR, 0, 0,
        0,          0,         1, 0,
      -centerX * sx * cosR + centerY * sy * sinR,
      -centerX * sx * sinR - centerY * sy * cosR,
        0, 1
      ]);
    }
    
    function createProjectionMatrix(scale = 1, rotation = 0) {
      const lons = baseCoordinates.map(c => c[0]);
      const lats = baseCoordinates.map(c => c[1]);
      const minLon = Math.min(...lons), maxLon = Math.max(...lons);
      const minLat = Math.min(...lats), maxLat = Math.max(...lats);
      const width = maxLon - minLon;
      const height = maxLat - minLat;
      const centerX = (minLon + maxLon) / 2;
      const centerY = (minLat + maxLat) / 2;
      
      return makeOrthoProjectionMatrix(centerX, centerY, width, height, canvas.width, canvas.height, scale, rotation);
    }

    // 기본 스타일 정의
    const solid0 = {
      scale:1,
      rotation:0,
      strokeColor: [0.08, 0.8, 1.0, 1.0],
      strokeWidth: 12.0,
      strokeOffset: -5.0,
      strokeCap: 0.0,
      strokeJoin: 0.0,
      strokeMiterLimit: 10.0,
      useStrokePattern: false
    };

    const dash0 = {
      scale: 1,
      rotation: 0,
      strokeColor: [1.0, 0.0, 0.0, 1.0],
      strokeWidth: 6.0,
      strokeOffset: 5.0,
      strokeCap: 4.0,
      strokeJoin: 0.0,
      strokeMiterLimit: 10.0,
      dashPattern: [20, 5, 20, 5],
      dashOffset: 0.0,
      useStrokePattern: false,
    };

    const pattern0 = {
      scale: 1,
      rotation: 0,
      strokeColor: [1.0, 1.0, 1.0, 1.0],
      strokeWidth: 12.0,
      strokeOffset: -5.0,
      strokeCap: 0.0,
      strokeJoin: 0.0,
      strokeMiterLimit: 10.0,
      useStrokePattern: true,
      strokePatternTextureSpacing: 20,
      strokePatternTextureStartOffset: 10,
      strokePatternTextureOffset: [0, 0],
    };

    // 피처 데이터
    const features = [
      {
        coordinates: baseCoordinates,
        styles: [
          solid0,
          { ...solid0, strokeColor: [1.0, 0.0, 0.0, 1.0] },
          { ...dash0, strokeColor: [0.5, 0.5, 0.0, 1.0]},
          { ...dash0, strokeColor: [0.5, 1.0, 0.5, 1.0], dashOffset: 5}, 
        ]
      }
    ];

    // WebGL 프로그램 생성
    const program = getProgram(fragmentShaderSource, vertexShaderSource);
    gl.useProgram(program);

    // 정점 버퍼 생성
    const quadVertices = new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]);
    const quadVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);

    // 인덱스 버퍼 생성
    const quadIndices = new Uint16Array([0, 1, 2, 1, 3, 2]);
    const quadIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quadIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, quadIndices, gl.STATIC_DRAW);    
    
    // 정점 어트리뷰트 설정
    gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);
    bindAttrib("a_position", 2, 0, 0, 0);
    
    // 렌더링 함수
    function render() {
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      
      let lineCount = 0;
      
      features.forEach(feature => {
        // 캐시에서 버퍼 가져오기
        const { buffer, instanceCount } = getOrCreateBuffer(feature.coordinates);
        lineCount += instanceCount;
        
        // 버퍼 바인딩
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        bindInstanceAttributes(instanceAttributes, 1);
        
        // 스타일별로 렌더링
        feature.styles.forEach(style => {
          setLineUniforms(style);
          ext.drawElementsInstancedANGLE(gl.TRIANGLES, quadIndices.length, gl.UNSIGNED_SHORT, 0, instanceCount);
        });
      });
      
      document.getElementById('lineCount').textContent = lineCount;
      updateFPS();
    }

    // FPS 측정
    let frameCount = 0;
    let lastFpsUpdate = performance.now();
    let fps = 0;
    
    function updateFPS() {
      frameCount++;
      const now = performance.now();
      const delta = now - lastFpsUpdate;
      
      if (delta >= 1000) {
        fps = Math.round(frameCount * 1000 / delta);
        frameCount = 0;
        lastFpsUpdate = now;
      }
      
      document.getElementById('fpsValue').textContent = fps;
    }

    // UI 이벤트 핸들러
    document.getElementById('lineWidth').addEventListener('input', function() {
      const value = this.value;
      document.getElementById('widthValue').textContent = value;
      features[0].styles[0].strokeWidth = parseFloat(value);
      render();
    });

    document.getElementById('lineOffset').addEventListener('input', function() {
      const value = this.value;
      document.getElementById('offsetValue').textContent = value;
      features[0].styles[0].strokeOffset = parseFloat(value);
      render();
    });

    document.getElementById('solidStyle').addEventListener('click', function() {
      features[0].styles[0] = { ...solid0 };
      render();
    });

    document.getElementById('dashedStyle').addEventListener('click', function() {
      features[0].styles[0] = { ...dash0 };
      render();
    });

    document.getElementById('patternStyle').addEventListener('click', function() {
      features[0].styles[0] = { ...pattern0 };
      render();
    });

    document.getElementById('addLine').addEventListener('click', function() {
      const newCoords = generateRandomCoordinates(baseCoordinates, 15, 0.03);
      features.push({
        coordinates: newCoords,
        styles: [
          { 
            ...solid0,
            strokeColor: [
              Math.random(), 
              Math.random(), 
              Math.random(), 
              1.0
            ],
            strokeWidth: 5 + Math.random() * 10
          }
        ]
      });
      render();
    });

    document.getElementById('clearLines').addEventListener('click', function() {
      // 첫 번째 피처는 유지
      while (features.length > 1) {
        features.pop();
      }
      render();
    });

    // 창 크기 변경 시 대응
    window.addEventListener('resize', function() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      render();
    });

    // 초기 렌더링
    render();
    updateStats();
  </script>
</body>
</html>
