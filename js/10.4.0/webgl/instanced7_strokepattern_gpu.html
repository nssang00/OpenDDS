<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Instanced Polyline Rendering with WebGL</title>
  <style>
    html,body,canvas {margin:0;width:100vw;height:100vh;display:block;background:#111;}
  </style>
</head>
<body>
  <canvas id="glcanvas" width="1024" height="768"></canvas>
  <script>
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl");
    const ext = gl.getExtension("ANGLE_instanced_arrays");
    if (!ext) throw "ANGLE_instanced_arrays not supported";

    // ====== Vertex shader ======
    const vertexShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

// instance buffer(divisor = 1)
attribute vec2 a_prevPos;
attribute vec2 a_startPos;
attribute vec2 a_endPos;
attribute vec2 a_nextPos;
attribute float a_distance;
attribute float a_pickId;

// static quad buffer(divisor = 0)
attribute vec2 a_quadCorner;

uniform mat4  u_projectionMatrix;
uniform vec2  u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_depth;
uniform float u_resolution;
uniform float u_strokeWidth;
uniform float u_strokeOffset;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;

varying vec2  v_segmentStart;
varying vec2  v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_distanceOffsetPx;
varying vec4  v_hitColor;
varying float v_angleTangentSum;
varying float v_segmentLength;
varying vec2  v_segmentTangent;

vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * (screenPos.xy / screenPos.w) + 0.5) * u_viewportSizePx;
}

vec4 pxToScreen(vec2 pxPos) {
  vec2 screen = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return vec4(screen, u_depth, 1.0);
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

vec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {
  float halfAngle = joinAngle / 2.0;
  float c = cos(halfAngle);
  float s = sin(halfAngle);
  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);
  float length = 1.0 / s;
  return angleBisectorNormal * length;
}

vec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {
  if (cos(joinAngle) > 0.998 || isCap(joinAngle))
    return point - normal * offsetPx;
  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;
}

vec4 colorEncodeId(float id) {
  float r = floor(id / 16777216.0);
  float g = floor(mod(id, 16777216.0) / 65536.0);
  float b = floor(mod(id, 65536.0) / 256.0);
  float a = floor(mod(id, 256.0));
  return vec4(r, g, b, a) / 255.0;
}
///////
float angleBetween(vec2 p0, vec2 pA, vec2 pB) {
  vec2 dirA = pA - p0;
  vec2 dirB = pB - p0;

  float lenA2 = dot(dirA, dirA);
  float lenB2 = dot(dirB, dirB);
  if (lenA2 < 1e-12 || lenB2 < 1e-12) return -1.0;

  float cross = dirA.x * dirB.y - dirA.y * dirB.x;
  float dotProduct = dot(dirA, dirB);
  
  float cosAngle = dotProduct / sqrt(lenA2 * lenB2);
  if (cosAngle > 0.985) return -1.0;
  
  float angle = atan(cross, dotProduct);
  
  return angle + (step(angle, 0.0) * TWO_PI);
}
/*
float angleBetween(vec2 p0, vec2 pA, vec2 pB) {
  vec2 dirA = pA - p0;
  vec2 dirB = pB - p0;

  float lenA2 = dot(dirA, dirA);
  float lenB2 = dot(dirB, dirB);
  if (lenA2 < 1e-6 || lenB2 < 1e-6) return -1.0;

  float cross = dirA.x * dirB.y - dirA.y * dirB.x;
  float dotProduct = dot(dirA, dirB);
  float angle = atan(cross, dotProduct);
  
  return angle + (step(angle, 0.0) * TWO_PI);
}
*/
void main() {
  // GPU에서 각도 계산
  float angleStart = -1.0;  // 기본값 (cap)
  float angleEnd = -1.0;    // 기본값 (cap)
  
  // 시작점 각도 계산 (prevPos와 startPos, endPos 사용)
  if (a_pickId > 0.0) {  // 첫 번째 세그먼트가 아닌 경우
    angleStart = angleBetween(a_startPos, a_endPos, a_prevPos);
  }
  
  // 끝점 각도 계산 (startPos, endPos, nextPos 사용)
  if (a_pickId < 65535.0) {  // 다음 세그먼트가 있는 경우 (임시 조건)
    angleEnd = angleBetween(a_endPos, a_startPos, a_nextPos);
  }
  
  v_angleStart = angleStart;
  v_angleEnd = angleEnd;

  float lineOffsetPx = 0.0;

  vec2 segmentStartPx = worldToPx(a_startPos);
  vec2 segmentEndPx = worldToPx(a_endPos);  
  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, u_strokeOffset);
  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, u_strokeOffset);
  
  float normalDir  = a_quadCorner.y < 0.0 ?  1.0 : -1.0;
  float tangentDir = a_quadCorner.x < 0.0 ?  1.0 : -1.0;
  float angle = a_quadCorner.x < 0.0 ? v_angleStart : v_angleEnd;
  vec2 joinDirection;  
  vec2  positionPx = a_quadCorner.x < 0.0 ? segmentStartPx : segmentEndPx;

  if (cos(angle) > 0.985 || isCap(angle)) {
    joinDirection = normalPx * normalDir - tangentPx * tangentDir;
  } else {
    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);
  }

  positionPx = positionPx + joinDirection * (u_strokeWidth * 0.5 + 1.);
  gl_Position = pxToScreen(positionPx);

  v_segmentStart = segmentStartPx;
  v_segmentEnd   = segmentEndPx;
  v_distanceOffsetPx = a_distance / u_resolution - (u_strokeOffset * 0.0); // angleTangentSum 제거
  v_hitColor = colorEncodeId(a_pickId);
  
  // GPU에서 angleTangentSum 계산
  float angleTangentSum = 0.0;
  if (angleStart > -0.1) {  // 유효한 각도인 경우
    angleTangentSum += tan((angleStart - PI) / 2.0);
  }
  if (angleEnd > -0.1) {    // 유효한 각도인 경우
    angleTangentSum += tan((PI - angleEnd) / 2.0);
  }
  v_angleTangentSum = angleTangentSum;
  
  v_segmentLength = length(segmentEndPx - segmentStartPx);
  v_segmentTangent = tangentPx;
}
`;

    // ====== Fragment shader ======
    const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
varying vec2  v_segmentStart;
varying vec2  v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying vec4  v_hitColor;
varying float v_distanceOffsetPx;
varying float v_angleTangentSum;
varying float v_segmentLength;
varying vec2  v_segmentTangent;

uniform float u_strokeWidth;
uniform sampler2D u_pattern;
uniform vec4 u_strokeColor;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_strokeCap;
uniform float u_strokeJoin;
uniform float u_strokeMiterLimit;

uniform float u_dashPattern[8];
uniform int u_dashCount;
uniform float u_dashOffset;

uniform bool u_useStrokePattern;
uniform sampler2D u_strokePatternTexture;
uniform vec2  u_strokePatternTextureSize;
uniform vec2  u_strokePatternTextureOffset;
uniform vec2 u_strokePatternTextureSampleSize;
uniform float u_strokePatternTextureSpacing;
uniform float u_strokePatternTextureStartOffset;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;

vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float startOffsetPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {
  float scaleFactor = sampleSize.y / lineWidth;
  float currentLengthScaled = currentLengthPx * scaleFactor;
  float spacingScaled = max(spacingPx * scaleFactor, sampleSize.x);
  float uCoordPx = mod(currentLengthScaled - startOffsetPx * scaleFactor + sampleSize.x, spacingScaled);
  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);
  if (uCoordPx > sampleSize.x - 1.0) return vec4(0.0);
  float vCoordPx = (0.5 - 0.5 * currentRadiusRatio) * sampleSize.y;
  vec2  texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize; 
  return texture2D(texture, texCoord);
}

float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType, float lineWidth) {
  float localDistance = mod(distance, dashLengthTotal);
  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;
  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);
  if (capType == 5.0) {
    distanceSegment -= lineWidth * 0.5;
  } else if (capType == 0.0) {
    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - lineWidth * 0.5);
  }
  return distanceSegment;
}

float dashDistanceField(float distance, float radius, float capType, float lineWidth,
  float dashPattern[8], int dashCount, float dashOffset) {

  float totalDashLength = 0.0;
  for (int i = 0; i < 8; ++i) {
    if (i >= dashCount) break;
    totalDashLength += dashPattern[i];
  }

  float minDistance = 1e6;
  float currentOffset = 0.0;
  for (int i = 0; i < 8; i += 2) {
    if (i + 1 >= dashCount) break;
    float dashLength = dashPattern[i];
    float gapLength = dashPattern[i+1];
    float dashDist = getSingleDashDistance(distance + dashOffset, radius, currentOffset, dashLength, totalDashLength, capType, lineWidth);
    minDistance = min(minDistance, dashDist);
    currentOffset += dashLength + gapLength;
  }
  return minDistance;
}

bool isCap(float a) { return a < -0.1; }
float segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  vec2 tangent = normalize(end - start);
  vec2 normal = vec2(-tangent.y, tangent.x);
  vec2 startToPoint = point - start;
  return abs(dot(startToPoint, normal)) - width * 0.5;
}
float buttCapDistanceField(vec2 point, vec2 start, vec2 end) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  return dot(startToPoint, -tangent);
}
float squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return buttCapDistanceField(point, start, end) - width * 0.5;
}
float roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  float onSegment = max(0., 1000. * dot(point - start, end - start));
  return length(point - start) - width * 0.5 - onSegment;
}

float roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return roundCapDistanceField(point, start, end, width);
}

float bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  float c = cos(joinAngle * 0.5);
  float s = sin(joinAngle * 0.5);
  float direction = -sign(sin(joinAngle));
  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);
  float radius = width * 0.5 * s;
  return dot(startToPoint, bisector * direction) - radius;
}

float miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  if (cos(joinAngle) > 0.985) {
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  float miterLength = 1. / sin(joinAngle * 0.5);
  float miterLimit = u_strokeMiterLimit;
  if (miterLength > miterLimit) {
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  return -1000.;
}

float capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {
   if (capType == 4.0) {
    return buttCapDistanceField(point, start, end);
  } else if (capType == 5.0) {
    return squareCapDistanceField(point, start, end, width);
  }
  return roundCapDistanceField(point, start, end, width);
}

float joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {
  if (joinType == 6.0) {
    return bevelJoinField(point, start, end, width, joinAngle);
  } else if (joinType == 7.0) {
    return miterJoinDistanceField(point, start, end, width, joinAngle);
  }
  return roundJoinDistanceField(point, start, end, width);
}

float computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {
  if (isCap(joinAngle)) {
    return capDistanceField(point, start, end, width, capType);
  }
  return joinDistanceField(point, start, end, width, joinAngle, joinType);
}

float distanceFromSegment(vec2 point, vec2 start, vec2 end) {
  vec2 tangent = end - start;
  vec2 startToPoint = point - start;
  float h = clamp(dot(startToPoint, tangent) / dot(tangent, tangent), 0.0, 1.0);
  return length(startToPoint - tangent * h);
}

void main() {
  vec2  currentPoint = gl_FragCoord.xy / u_pixelRatio;

  float segmentLength = v_segmentLength;
  vec2 segmentTangent = v_segmentTangent;

  float currentLengthPx = max(0., min(dot(segmentTangent, currentPoint - v_segmentStart), segmentLength)) + v_distanceOffsetPx;

  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, u_strokeWidth, v_angleStart, u_strokeCap, u_strokeJoin);
  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, u_strokeWidth, v_angleEnd, u_strokeCap, u_strokeJoin);
  float distanceField = max(
    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, u_strokeWidth),
    max(segmentStartDistance, segmentEndDistance)
  );

  float dashField = -1000.0;
  if (u_dashCount > 0) {
    float currentRadiusPx = distanceFromSegment(currentPoint, v_segmentStart, v_segmentEnd);
    dashField = dashDistanceField(currentLengthPx, currentRadiusPx, u_strokeCap, u_strokeWidth, u_dashPattern, u_dashCount, u_dashOffset);
  }
  distanceField = max(distanceField, dashField);

  vec4 color = u_strokeColor;
  if (u_useStrokePattern) {
    vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);
    float currentRadiusRatio = dot(segmentNormal, currentPoint - v_segmentStart) * 2. / u_strokeWidth;  
    color = u_strokeColor * sampleStrokePattern(
      u_strokePatternTexture,
      u_strokePatternTextureSize,
      u_strokePatternTextureOffset,
      u_strokePatternTextureSampleSize,
      u_strokePatternTextureSpacing,
      u_strokePatternTextureStartOffset,
      currentLengthPx,
      currentRadiusRatio,
      u_strokeWidth
    );
  }

  color.a *= smoothstep(0.5, -0.5, distanceField);
  gl_FragColor = color;
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;

  if(gl_FragColor.a < 0.1) { discard; }
}
`;

    function compileShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw gl.getShaderInfoLog(shader);
      }
      return shader;
    }

    function getProgram(fragmentShaderSource, vertexShaderSource) {
      const program = gl.createProgram();
      gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vertexShaderSource));
      gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource));
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw gl.getShaderInfoLog(program);
      }
      return program;
    }
    
    const instanceAttributes = [
      { name: "a_prevPos", size: 2 },
      { name: "a_startPos", size: 2 },
      { name: "a_endPos", size: 2 },
      { name: "a_nextPos", size: 2 },
      { name: "a_distance", size: 1 },
      { name: "a_pickId", size: 1 }
    ];

    const coordinates = [
      [-122.48369693756104, 37.83381888486939],
      [-122.48348236083984, 37.83317489144141],
      [-122.48339653015138, 37.83270036637107],
      [-122.48356819152832, 37.832056363179625],
      [-122.48404026031496, 37.83114119107971],
      [-122.48404026031496, 37.83049717427869],
      [-122.48348236083984, 37.829920943955045],
      [-122.48356819152832, 37.82954808664175],
      [-122.48507022857666, 37.82944639795659],
      [-122.48610019683838, 37.82880236636284],
      [-122.48695850372314, 37.82931081282506],
      [-122.48700141906738, 37.83080223556934],
      [-122.48751640319824, 37.83168351665737],
      [-122.48803138732912, 37.832158048267786],
      [-122.48888969421387, 37.83297152392784],
      [-122.48987674713133, 37.83263257682617],
      [-122.49043464660643, 37.832937629287755],
      [-122.49125003814696, 37.832429207817725],
      [-122.49163627624512, 37.832564787218985],
      [-122.49223709106445, 37.83337825839438],
      [-122.49378204345702, 37.83368330777276]
    ];

    const zigzagCoordinates = [
      [-122.493782, 37.833683], 
      [-122.492782, 37.829921],  
      [-122.491782, 37.832683],
      [-122.490782, 37.829921],
      [-122.489782, 37.832683],
      [-122.488782, 37.829921],
      [-122.487782, 37.832683],
      [-122.486782, 37.829921],
      [-122.485782, 37.832683],
      [-122.483696, 37.829921], 
    ];

    function makeOrthoProjectionMatrix(centerX, centerY, bboxWidth, bboxHeight, viewWidth, viewHeight, scale = 1, rotation = 0) {
      const baseRes = Math.max(bboxWidth / viewWidth, bboxHeight / viewHeight);
      const sx = 2 / (viewWidth * baseRes * scale);
      const sy = 2 / (viewHeight * baseRes * scale);

      const cosR = Math.cos(rotation);
      const sinR = Math.sin(rotation);

      return new Float32Array([
        sx * cosR,  sx * sinR, 0, 0,
      -sy * sinR,  sy * cosR, 0, 0,
        0,          0,         1, 0,
      -centerX * sx * cosR + centerY * sy * sinR,
      -centerX * sx * sinR - centerY * sy * cosR,
        0, 1
      ]);
    }
    
    const lons = coordinates.map(c => c[0]);
    const lats = coordinates.map(c => c[1]);
    const minLon = Math.min(...lons), maxLon = Math.max(...lons);
    const minLat = Math.min(...lats), maxLat = Math.max(...lats);
        
    function createProjectionMatrix(scale = 1, rotation = 0) {
      return makeOrthoProjectionMatrix((minLon + maxLon) / 2, (minLat + maxLat) / 2, maxLon - minLon, maxLat - minLat, canvas.width, canvas.height, scale, rotation);
    }

    function createInstanceData(coords) {
      const instanceCount = coords.length - 1;
      const instanceData = [];

      let distance = 0;

      for (let i = 0; i < instanceCount; i++) {
        // 이전, 현재, 다음 점 계산
        const prevPos = i > 0 ? coords[i - 1] : coords[i];  // 첫 번째는 자기 자신
        const startPos = coords[i];
        const endPos = coords[i + 1];
        const nextPos = i < instanceCount - 1 ? coords[i + 2] : coords[i + 1];  // 마지막은 자기 자신

        instanceData.push(
          prevPos[0], prevPos[1],   // a_prevPos
          startPos[0], startPos[1], // a_startPos
          endPos[0], endPos[1],     // a_endPos
          nextPos[0], nextPos[1],   // a_nextPos
          distance,                 // a_distance (누적 거리)
          i                         // a_pickId
        );

        // 거리 누적 (단순히 유클리드 거리 사용)
        distance += Math.hypot(endPos[0] - startPos[0], endPos[1] - startPos[1]);
      }

      return {
        instanceData: new Float32Array(instanceData),
        instanceCount
      };
    }

    function bindAttrib(name, size, stride, offset, div) {
      const location = gl.getAttribLocation(program, name);
      gl.enableVertexAttribArray(location);
      gl.vertexAttribPointer(location, size, gl.FLOAT, false, stride, offset);
      ext.vertexAttribDivisorANGLE(location, div);
    }

    function bindInstanceAttributes(attribs, divisor = 1) {
      const stride = attribs.reduce((sum, a) => sum + a.size, 0) * 4;
      let offset = 0;
      for (const attr of attribs) {
        bindAttrib(attr.name, attr.size, stride, offset, divisor);
        offset += attr.size * 4;
      }
    }

    function createPatternCanvas(width = 20, height = 20) {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "green";
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = "red";
      ctx.fillRect(width * 0.4, 0, width * 0.2, height);
      ctx.fillRect(0, height * 0.4, width, height * 0.2);
      return canvas;
    }
    
    function setLineUniforms(style) {
      // ====== Static Uniforms ======
      gl.uniformMatrix4fv(gl.getUniformLocation(program, "u_projectionMatrix"), false, createProjectionMatrix(style.scale, style.rotation));
      gl.uniform2f(gl.getUniformLocation(program, "u_viewportSizePx"), canvas.width, canvas.height);
      gl.uniform1f(gl.getUniformLocation(program, "u_pixelRatio"), window.devicePixelRatio || 1);
      gl.uniform1f(gl.getUniformLocation(program, "u_globalAlpha"), 1.0);
      gl.uniform1f(gl.getUniformLocation(program, "u_depth"), 0.0);
      gl.uniform1f(gl.getUniformLocation(program, "u_resolution"), 1.0);

      gl.uniform4f(gl.getUniformLocation(program, "u_strokeColor"), ...style.strokeColor);
      gl.uniform1f(gl.getUniformLocation(program, "u_strokeWidth"), style.strokeWidth);    
      gl.uniform1f(gl.getUniformLocation(program, "u_strokeOffset"), style.strokeOffset);
      gl.uniform1f(gl.getUniformLocation(program, "u_strokeCap"), style.strokeCap);
      gl.uniform1f(gl.getUniformLocation(program, "u_strokeJoin"), style.strokeJoin);
      gl.uniform1f(gl.getUniformLocation(program, "u_strokeMiterLimit"), style.strokeMiterLimit);
      
      gl.uniform1i(gl.getUniformLocation(program, "u_useStrokePattern"), style.useStrokePattern);    

      if (style.useStrokePattern) {
        let width = 20;
        let height = 20;     
        let textureSlot = 0;
        
        const patternTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0 + textureSlot);
        gl.bindTexture(gl.TEXTURE_2D, patternTexture);
        gl.uniform1i(gl.getUniformLocation(program, "u_strokePatternTexture"), textureSlot);
        
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, createPatternCanvas(width, height));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  
        gl.uniform2f(gl.getUniformLocation(program, "u_strokePatternTextureSize"), width, height);
        gl.uniform2f(gl.getUniformLocation(program, "u_strokePatternTextureOffset"), ...style.strokePatternTextureOffset);
        gl.uniform2f(gl.getUniformLocation(program, "u_strokePatternTextureSampleSize"), width, height);
        gl.uniform1f(gl.getUniformLocation(program, "u_strokePatternTextureSpacing"), style.strokePatternTextureSpacing);
        gl.uniform1f(gl.getUniformLocation(program, "u_strokePatternTextureStartOffset"), style.strokePatternTextureStartOffset);
        
        gl.uniform1i(gl.getUniformLocation(program, "u_dashCount"), 0);
      }
      else if(style.dashPattern && style.dashPattern.length > 0)
      {
        gl.uniform1fv(gl.getUniformLocation(program, "u_dashPattern"), new Float32Array(style.dashPattern));
        gl.uniform1i(gl.getUniformLocation(program, "u_dashCount"), style.dashPattern.length);
        gl.uniform1f(gl.getUniformLocation(program, "u_dashOffset"), style.dashOffset);
      } else {
        gl.uniform1i(gl.getUniformLocation(program, "u_dashCount"), 0);
      }
    }

    // 스타일 정의
    const solid0 = {
      scale:1,
      rotation:0,
      strokeColor: [0.08, 0.8, 1.0, 1.0],
      strokeWidth: 12.0,
      strokeOffset: -5.0,
      strokeCap: 0.0,
      strokeJoin: 0.0,
      strokeMiterLimit: 10.0,
    };

    const dash0 = {
      scale: 1,
      rotation: 0,
      strokeColor: [1.0, 0.0, 0.0, 1.0],
      strokeWidth: 12.0,
      strokeOffset: 5.0,
      strokeCap: 4.0,
      strokeJoin: 0.0,
      strokeMiterLimit: 10.0,
      dashPattern: [20, 5, 20, 5],
      dashOffset: 0.0,
      useStrokePattern: false,
    };

    const pattern0 = {
      scale: 1,
      rotation: 0,
      strokeColor: [1.0, 1.0, 1.0, 1.0],
      strokeWidth: 12.0,
      strokeOffset: -5.0,
      strokeCap: 0.0,
      strokeJoin: 0.0,
      strokeMiterLimit: 10.0,
      useStrokePattern: true,
      strokePatternTextureSpacing: 20,
      strokePatternTextureStartOffset: 10,
      strokePatternTextureOffset: [0, 0],
    };

    const features = [
      {
        coordinates: coordinates,
        styles: [
          solid0,
          { ...solid0, strokeOffset: 5, strokeWidth:6, strokeColor: [1.0, 0.0, 0.0, 1.0] },
          { ...dash0, dashPattern: [3,40,3,40], strokeColor: [0.5, 0.5, 1.0, 1.0]},
          { ...dash0, dashPattern: [3,40,3,40], strokeColor: [0.5, 1.0, 0.5, 1.0], dashOffset: 20}, 
          { ...pattern0, strokeWidth: 8, strokePatternTextureSpacing: 40, strokePatternTextureStartOffset: 40}, 
          { ...pattern0, strokeWidth:12, strokePatternTextureSpacing: 40, strokePatternTextureStartOffset: 20}, 
        ],
      },
      {
        coordinates: zigzagCoordinates,
        styles: [
          { ...dash0, strokeWidth:6, dashPattern: [20,5,20,5], strokeColor: [0.8, 0.5, 1.0, 1.0]},
          { ...pattern0, strokeWidth: 8, rotation:90 * (Math.PI / 180)}, 
        ]
      }
    ];

    const bufferCache = new WeakMap();
    function getOrCreateBuffer(coords) {
      if (bufferCache.has(coords)) {
        return bufferCache.get(coords);
      }
      const { instanceData, instanceCount } = createInstanceData(coords);
      const instanceBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, instanceData, gl.STATIC_DRAW);

      const buffers = { instanceBuffer, instanceCount };
      bufferCache.set(coords, buffers);
      return buffers;
    }

    const program = getProgram(fragmentShaderSource, vertexShaderSource);
    gl.useProgram(program);

    // Create vertex buffer (quad)
    const quadVertices = new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]);
    const quadVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);

    // Create index buffer (triangles)
    const quadIndices = new Uint16Array([0, 1, 2, 1, 3, 2]);
    const quadIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quadIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, quadIndices, gl.STATIC_DRAW);    
    
    // Set up vertex attributes
    gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);
    bindAttrib("a_quadCorner", 2, 0, 0, 0);

    function render(scale) {
      // ====== Draw ======
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
  
      features.forEach(feature => {
        const { instanceBuffer, instanceCount } = getOrCreateBuffer(feature.coordinates);
        // Bind instance buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
        bindInstanceAttributes(instanceAttributes, 1);
        
        feature.styles.forEach(style => {
          setLineUniforms({ ...style, scale: scale });
          ext.drawElementsInstancedANGLE(gl.TRIANGLES, quadIndices.length, gl.UNSIGNED_SHORT, 0, instanceCount);
        });
      });
    }

    let currentScale = 1.0;
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
    
      currentScale = Math.max(0.2, Math.min(10.0, currentScale - Math.sign(e.deltaY) * 0.2));
      render(currentScale);
    }, { passive: false });

    render(1.0);
  </script>
</body>
</html>
