<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Thick Polyline - Fixed Round Joins</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        min-height: 100vh;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        padding: 20px;
        background: linear-gradient(135deg, #4776e6, #8e54e9);
        color: #e6e6e6;
      }
      header {
        margin-bottom: 20px;
        text-align: center;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      h1 {
        font-size: 2.2rem;
        margin-bottom: 8px;
        color: #4cc9f0;
        text-shadow: 0 0 10px rgba(76, 201, 240, 0.3);
      }
      .subtitle {
        opacity: 0.8;
      }
      .container {
        flex: 1;
        display: flex;
        gap: 20px;
      }
      .controls {
        width: 300px;
        padding: 20px;
        border-radius: 10px;
        backdrop-filter: blur(5px);
        background: rgba(255, 255, 255, 0.05);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }
      .control-group {
        margin-bottom: 25px;
      }
      h2 {
        font-size: 1.3rem;
        margin-bottom: 15px;
        color: #f72585;
      }
      label {
        font-size: 0.95rem;
        margin: 10px 0 5px;
        display: block;
      }
      input[type="range"] {
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
      }
      select,
      button {
        width: 100%;
        padding: 10px;
        border-radius: 5px;
        cursor: pointer;
        transition: 0.3s;
        font-size: 1rem;
        color: #e6e6e6;
      }
      select {
        background: rgba(76, 201, 240, 0.15);
        border: 1px solid rgba(76, 201, 240, 0.3);
      }
      select:hover {
        background: rgba(76, 201, 240, 0.25);
        border-color: rgba(76, 201, 240, 0.5);
      }
      button {
        margin-top: 15px;
        font-weight: 700;
        background: rgba(247, 37, 133, 0.2);
        border: 1px solid rgba(247, 37, 133, 0.4);
      }
      button:hover {
        background: rgba(247, 37, 133, 0.3);
      }
      .canvas-container {
        flex: 1;
        position: relative;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        background: rgba(0, 0, 0, 0.3);
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      .info-panel {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-size: 0.9rem;
        background: rgba(0, 0, 0, 0.5);
        padding: 15px;
        border-radius: 8px;
        max-width: 300px;
      }
      .join-examples {
        display: flex;
        justify-content: space-between;
        margin-top: 15px;
        text-align: center;
      }
      .join-example {
        flex: 1;
        margin: 0 5px;
        padding: 10px;
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.05);
      }
      .join-title {
        font-weight: 700;
        color: #4cc9f0;
        margin-bottom: 5px;
      }
      .join-desc {
        font-size: 0.8rem;
        opacity: 0.7;
      }
      .value-display {
        min-width: 40px;
        display: inline-block;
        text-align: right;
        color: #4cc9f0;
        font-weight: 700;
      }
      @media (max-width: 768px) {
        .container {
          flex-direction: column;
        }
        .controls {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Thick Polyline with WebGL</h1>
      <p class="subtitle">Round-Join Crack Fix Applied</p>
    </header>

    <div class="container">
      <div class="controls">
        <div class="control-group">
          <h2>Line Properties</h2>
          <label
            >Join Type:
            <select id="join-type">
              <option value="miter">Miter</option>
              <option value="bevel">Bevel</option>
              <option value="round" selected>Round</option>
            </select>
          </label>

          <label
            >Line Width:
            <span id="width-val" class="value-display">24</span> px</label
          >
          <input type="range" id="line-width" min="5" max="60" value="24" />

          <label
            >Miter Limit:
            <span id="miter-val" class="value-display">4.0</span></label
          >
          <input
            type="range"
            id="miter-limit"
            min="1"
            max="10"
            step=".5"
            value="4"
          />
        </div>

        <div class="control-group">
          <h2>Appearance</h2>
          <label
            >Line Color:
            <select id="line-color">
              <option value="#FF3B30">Red</option>
              <option value="#4CD964" selected>Green</option>
              <option value="#5AC8FA">Blue</option>
              <option value="#FF9500">Orange</option>
              <option value="#FFCC00">Yellow</option>
              <option value="#AF52DE">Purple</option>
            </select>
          </label>

          <label
            >Background:
            <select id="bg-theme">
              <option value="dark">Dark</option>
              <option value="light">Light</option>
              <option value="blue">Blue Gradient</option>
              <option value="purple" selected>Purple Gradient</option>
            </select>
          </label>
        </div>
        <button id="reset-btn">Reset</button>
      </div>

      <div class="canvas-container">
        <canvas id="glcanvas"></canvas>
        <div class="info-panel">
          <div id="vertex-info">Vertices: 0</div>
          <div id="segment-info">Segments: 0</div>
          <div class="join-examples">
            <div class="join-example">
              <div class="join-title">Miter</div>
              <div class="join-desc">Sharp</div>
            </div>
            <div class="join-example">
              <div class="join-title">Bevel</div>
              <div class="join-desc">Flat</div>
            </div>
            <div class="join-example">
              <div class="join-title">Round</div>
              <div class="join-desc">Smooth</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <footer
      style="text-align: center; opacity: 0.7; padding: 20px; font-size: 0.9rem"
    >
      WebGL thick-polyline demo – round-join cracks fixed ✓
    </footer>

    <script>
      // ───────── Sample path (MapLibre/dev route) ─────────
      const route = [
        [-122.48369693756104, 37.83381888486939],
        [-122.48348236083984, 37.83317489144141],
        [-122.48339653015138, 37.83270036637107],
        [-122.48356819152832, 37.832056363179625],
        [-122.48404026031496, 37.83114119107971],
        [-122.48404026031496, 37.83049717427869],
        [-122.48348236083984, 37.829920943955045],
        [-122.48356819152832, 37.82954808664175],
        [-122.48507022857666, 37.82944639795659],
        [-122.48610019683838, 37.82880236636284],
        [-122.48695850372314, 37.82931081282506],
        [-122.48700141906738, 37.83080223556934],
        [-122.48751640319824, 37.83168351665737],
        [-122.48803138732912, 37.832158048267786],
        [-122.48888969421387, 37.83297152392784],
        [-122.48987674713133, 37.83263257682617],
        [-122.49043464660643, 37.832937629287755],
        [-122.49125003814696, 37.832429207817725],
        [-122.49163627624512, 37.832564787218985],
        [-122.49223709106445, 37.83337825839438],
        [-122.49378204345702, 37.83368330777276],
      ];

      // ───────── Math helpers ─────────
      const R = 6378137,
        rad = (d) => (d * Math.PI) / 180,
        toXY = ([lng, lat], bLat) => [
          rad(lng) * R * Math.cos(rad(bLat)),
          rad(lat) * R,
        ];
      const sub = (a, b) => [a[0] - b[0], a[1] - b[1]],
        add = (a, b) => [a[0] + b[0], a[1] + b[1]],
        scale = (v, s) => [v[0] * s, v[1] * s];
      const len = (v) => Math.hypot(v[0], v[1]),
        norm = (v) => {
          const l = len(v);
          return l ? [v[0] / l, v[1] / l] : [0, 0];
        },
        perp = (v) => [-v[1], v[0]];
      const dot = (a, b) => a[0] * b[0] + a[1] * b[1],
        cross = (a, b) => a[0] * b[1] - a[1] * b[0],
        angleBetween = (a, b) =>
          Math.acos(Math.max(-1, Math.min(1, dot(a, b))));
      const rotate = (v, a) => {
        const c = Math.cos(a),
          s = Math.sin(a);
        return [v[0] * c - v[1] * s, v[0] * s + v[1] * c];
      };

      // ───────── Fixed mesh builder (round-join crack fix) ─────────
      function buildMesh(lngLat, width = 24, join = "round", miterLimit = 4) {
        const baseLat = lngLat[0][1];
        const pts = lngLat.map((c) => toXY(c, baseLat));
        const dir = [],
          normL = [];
        for (let i = 0; i < pts.length - 1; i++) {
          const d = norm(sub(pts[i + 1], pts[i]));
          dir.push(d);
          normL.push(perp(d));
        }
        const v = [],
          idx = [];
        let vc = 0;

        // first cap
        v.push(
          ...add(pts[0], scale(normL[0], width / 2)),
          ...sub(pts[0], scale(normL[0], width / 2))
        );
        vc += 2;

        for (let i = 1; i < pts.length - 1; i++) {
          const nPrev = normL[i - 1],
            nNext = normL[i],
            e = add(nPrev, nNext),
            eLen = len(e);

          if (join === "bevel" || (join === "miter" && eLen < 1e-6)) {
            const l1 = add(pts[i], scale(nPrev, width / 2)),
              r1 = sub(pts[i], scale(nPrev, width / 2));
            const l2 = add(pts[i], scale(nNext, width / 2)),
              r2 = sub(pts[i], scale(nNext, width / 2));
            v.push(...l1, ...r1, ...l2, ...r2);
            idx.push(
              vc - 2,
              vc - 1,
              vc,
              vc - 1,
              vc + 1,
              vc,
              vc,
              vc + 1,
              vc + 2,
              vc + 1,
              vc + 3,
              vc + 2
            );
            vc += 4;
          } else if (join === "round") {
            // FIXED: Round join implementation
            const ang = angleBetween(nPrev, nNext);
            const rotDir = cross(nPrev, nNext) > 0 ? 1 : -1;
            const segs = Math.max(4, Math.min(16, Math.ceil(ang * 8)));

            // Add starting vertices for the round join
            const sl = add(pts[i], scale(nPrev, width / 2));
            const sr = sub(pts[i], scale(nPrev, width / 2));
            v.push(...sl, ...sr);

            // Connect with previous segment
            idx.push(vc - 2, vc - 1, vc, vc - 1, vc + 1, vc);
            vc += 2;

            // Generate round join segments
            for (let j = 1; j <= segs; j++) {
              const t = j / segs;
              const rotA = t * ang * rotDir;
              const vec = rotate(nPrev, rotA);
              const l = add(pts[i], scale(vec, width / 2));
              const r = sub(pts[i], scale(vec, width / 2));
              v.push(...l, ...r);

              // FIXED: Proper triangle winding for round segments
              idx.push(
                vc - 2,
                vc - 1,
                vc, // left triangle
                vc - 1,
                vc + 1,
                vc // right triangle
              );
              vc += 2;
            }
          } else {
            // miter
            const eHat = norm(e),
              mLen = width / 2 / Math.max(0.1, dot(eHat, nPrev));
            if (join === "miter" && mLen > width * miterLimit) {
              // fallback to bevel
              const l1 = add(pts[i], scale(nPrev, width / 2)),
                r1 = sub(pts[i], scale(nPrev, width / 2));
              const l2 = add(pts[i], scale(nNext, width / 2)),
                r2 = sub(pts[i], scale(nNext, width / 2));
              v.push(...l1, ...r1, ...l2, ...r2);
              idx.push(
                vc - 2,
                vc - 1,
                vc,
                vc - 1,
                vc + 1,
                vc,
                vc,
                vc + 1,
                vc + 2,
                vc + 1,
                vc + 3,
                vc + 2
              );
              vc += 4;
            } else {
              const ext = scale(eHat, mLen);
              v.push(...add(pts[i], ext), ...sub(pts[i], ext));
              idx.push(vc - 2, vc - 1, vc, vc - 1, vc + 1, vc);
              vc += 2;
            }
          }
        }

        // last segment and cap
        const nLast = normL[normL.length - 1];
        v.push(
          ...add(pts.at(-1), scale(nLast, width / 2)),
          ...sub(pts.at(-1), scale(nLast, width / 2))
        );
        idx.push(vc - 2, vc - 1, vc, vc - 1, vc + 1, vc);
        vc += 2;

        // fit to clip-space
        const xs = v.filter((_, i) => !(i & 1)),
          ys = v.filter((_, i) => i & 1);
        const minX = Math.min(...xs),
          maxX = Math.max(...xs),
          minY = Math.min(...ys),
          maxY = Math.max(...ys);
        const s = 0.9 / Math.max(maxX - minX, maxY - minY),
          cX = (minX + maxX) / 2,
          cY = (minY + maxY) / 2;
        for (let i = 0; i < v.length; i += 2) {
          v[i] = (v[i] - cX) * s;
          v[i + 1] = (v[i + 1] - cY) * s;
        }

        return {
          vertices: new Float32Array(v),
          indices: new Uint16Array(idx),
          vc: v.length / 2,
          sc: idx.length / 3,
        };
      }

      // ───────── WebGL init ─────────
      const canvas = document.getElementById("glcanvas"),
        gl = canvas.getContext("webgl", { antialias: true });
      if (!gl) alert("WebGL unsupported");

      const vsSrc = `attribute vec2 a_xy;void main(){gl_Position=vec4(a_xy,0.0,1.0);}`;
      const fsSrc = `precision mediump float;uniform vec4 u_color;void main(){gl_FragColor=u_color;}`;

      function compile(t, s) {
        const sh = gl.createShader(t);
        gl.shaderSource(sh, s);
        gl.compileShader(sh);
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS))
          throw gl.getShaderInfoLog(sh);
        return sh;
      }

      const prog = gl.createProgram();
      gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsSrc));
      gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsSrc));
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
        throw gl.getProgramInfoLog(prog);
      gl.useProgram(prog);

      const locXY = gl.getAttribLocation(prog, "a_xy"),
        locClr = gl.getUniformLocation(prog, "u_color");
      let vbo = null,
        ebo = null,
        current = { vertices: new Float32Array(), indices: new Uint16Array() };

      function upload(mesh) {
        if (vbo) gl.deleteBuffer(vbo);
        if (ebo) gl.deleteBuffer(ebo);
        vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);
        ebo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(locXY);
        gl.vertexAttribPointer(locXY, 2, gl.FLOAT, false, 0, 0);
        document.getElementById(
          "vertex-info"
        ).textContent = `Vertices: ${mesh.vc}`;
        document.getElementById(
          "segment-info"
        ).textContent = `Triangles: ${mesh.sc}`;
      }

      function render() {
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        if (current.indices.length)
          gl.drawElements(
            gl.TRIANGLES,
            current.indices.length,
            gl.UNSIGNED_SHORT,
            0
          );
      }

      function hex2rgb(h) {
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
        return m
          ? {
              r: parseInt(m[1], 16),
              g: parseInt(m[2], 16),
              b: parseInt(m[3], 16),
            }
          : { r: 0, g: 0, b: 0 };
      }

      // ───────── UI wiring ─────────
      const ui = {
        join: document.getElementById("join-type"),
        width: document.getElementById("line-width"),
        miter: document.getElementById("miter-limit"),
        color: document.getElementById("line-color"),
        bg: document.getElementById("bg-theme"),
        reset: document.getElementById("reset-btn"),
        wval: document.getElementById("width-val"),
        mval: document.getElementById("miter-val"),
      };

      const st = {
        join: "round",
        width: 24,
        miter: 4,
        color: "#4CD964",
        bg: "purple",
      };

      function setBg(t) {
        const g = {
          dark: "linear-gradient(135deg,#1a1a2e,#16213e)",
          light: "linear-gradient(135deg,#f5f7fa,#c3cfe2)",
          blue: "linear-gradient(135deg,#1a2a6c,#2a5298)",
          purple: "linear-gradient(135deg,#4776E6,#8E54E9)",
        };
        document.body.style.background = g[t] || g.dark;
      }

      function refresh() {
        current = buildMesh(route, st.width, st.join, st.miter);
        upload(current);
        const c = hex2rgb(st.color);
        gl.uniform4f(locClr, c.r / 255, c.g / 255, c.b / 255, 1);
        render();
      }

      ui.join.onchange = () => {
        st.join = ui.join.value;
        refresh();
      };
      ui.width.oninput = () => {
        st.width = +ui.width.value;
        ui.wval.textContent = st.width;
        refresh();
      };
      ui.miter.oninput = () => {
        st.miter = +ui.miter.value;
        ui.mval.textContent = st.miter.toFixed(1);
        refresh();
      };
      ui.color.onchange = () => {
        st.color = ui.color.value;
        refresh();
      };
      ui.bg.onchange = () => {
        st.bg = ui.bg.value;
        setBg(st.bg);
      };
      ui.reset.onclick = () => {
        Object.assign(st, {
          join: "round",
          width: 24,
          miter: 4,
          color: "#4CD964",
          bg: "purple",
        });
        ui.join.value = st.join;
        ui.width.value = st.width;
        ui.wval.textContent = st.width;
        ui.miter.value = st.miter;
        ui.mval.textContent = st.miter.toFixed(1);
        ui.color.value = st.color;
        ui.bg.value = st.bg;
        setBg(st.bg);
        refresh();
      };

      function resize() {
        canvas.width = canvas.clientWidth * devicePixelRatio;
        canvas.height = canvas.clientHeight * devicePixelRatio;
        gl.viewport(0, 0, canvas.width, canvas.height);
        render();
      }

      window.addEventListener("resize", resize);
      resize();
      setBg(st.bg);
      refresh();
    </script>
  </body>
</html>
