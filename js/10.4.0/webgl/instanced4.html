<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Miter Join Instanced Line</title>
  <style>
    html,body,canvas {margin:0;width:100vw;height:100vh;display:block;background:#111;}
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById("glcanvas");
// 고해상도 대응
function fitCanvas() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = canvas.clientWidth * dpr;
  canvas.height = canvas.clientHeight * dpr;
}
fitCanvas();

const gl = canvas.getContext("webgl");
const ext = gl.getExtension("ANGLE_instanced_arrays");
if (!ext) throw "ANGLE_instanced_arrays 미지원";

// ======= 셰이더 소스 =======
const vertexShaderSource = `
precision mediump float;
attribute vec2 a_position;        // (-1/1, -1/1) 쿼드
attribute vec2 a_segmentStart;   // 인스턴스: 선분 시작(norm)
attribute vec2 a_segmentEnd;     // 인스턴스: 선분 끝(norm)
attribute vec2 a_joinAngles;     // 인스턴스: 조인 각 (cosθ, sinθ)
uniform vec2  u_viewSize;
uniform float u_halfWidth;
uniform float u_miterLimit;
void main(){
  vec2 startPx = a_segmentStart * u_viewSize;
  vec2 endPx   = a_segmentEnd * u_viewSize;
  vec2 t = normalize(endPx - startPx);
  vec2 n = vec2(-t.y, t.x);
  vec2 offset = n * a_position.y * u_halfWidth;
  float s = (a_position.x + 1.0) * 0.5;
  vec2 posPx = mix(startPx, endPx, s);

  // (시작점에서만) 마이터 조인 처리
  if (s < 0.5) {
    float cosA = a_joinAngles.x, sinA = a_joinAngles.y;
    float miterLen = u_halfWidth / max(0.1, cosA);
    if (abs(miterLen) < u_miterLimit * u_halfWidth) {
      // bisector = 회전된 노말
      vec2 bisector = normalize(vec2(
        n.x * cosA - n.y * sinA,
        n.x * sinA + n.y * cosA
      ));
      offset = bisector * a_position.y * miterLen;
    } else {
      offset = n * a_position.y * u_halfWidth; // bevel fallback
    }
  }
  posPx += offset;
  vec2 clip = posPx / u_viewSize * 2.0 - 1.0;
  gl_Position = vec4(clip, 0.0, 1.0);
}`;
const fragmentShaderSource = `
precision mediump float;
void main(){ gl_FragColor = vec4(0.08,0.8,1.0,1.0); }`;

// ======= 셰이더 컴파일 =======
function compileShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    throw gl.getShaderInfoLog(shader);
  return shader;
}
const program = gl.createProgram();
gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vertexShaderSource));
gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource));
gl.linkProgram(program);
gl.useProgram(program);

// ======= routeLL → 정규화, 세그먼트, 조인각 =======
const routeLL = [
  [-122.48369693756104, 37.83381888486939],
  [-122.48348236083984, 37.83317489144141],
  [-122.48339653015138, 37.83270036637107],
  [-122.48356819152832, 37.832056363179625],
  [-122.48404026031496, 37.83114119107971],
  [-122.48404026031496, 37.83049717427869],
  [-122.48348236083984, 37.829920943955045],
  [-122.48356819152832, 37.82954808664175],
  [-122.48507022857666, 37.82944639795659],
  [-122.48610019683838, 37.82880236636284],
  [-122.48695850372314, 37.82931081282506],
  [-122.48700141906738, 37.83080223556934],
  [-122.48751640319824, 37.83168351665737],
  [-122.48803138732912, 37.832158048267786],
  [-122.48888969421387, 37.83297152392784],
  [-122.48987674713133, 37.83263257682617],
  [-122.49043464660643, 37.832937629287755],
  [-122.49125003814696, 37.832429207817725],
  [-122.49163627624512, 37.832564787218985],
  [-122.49223709106445, 37.83337825839438],
  [-122.49378204345702, 37.83368330777276],
];

// 정규화: 0~1 범위로
function normalizeCoords(coords) {
  const lons = coords.map(p => p[0]);
  const lats = coords.map(p => p[1]);
  const minLon = Math.min(...lons), maxLon = Math.max(...lons);
  const minLat = Math.min(...lats), maxLat = Math.max(...lats);
  return coords.map(([lon, lat]) => [
    (lon - minLon) / (maxLon - minLon),
    (lat - minLat) / (maxLat - minLat)
  ]);
}
const norm = normalizeCoords(routeLL);

// 세그먼트 & 조인각 준비
const segCount = norm.length - 1;
const segments = new Float32Array(segCount * 4);
const joinAngles = new Float32Array(segCount * 2);

function normalizeVec2(v) {
  const len = Math.hypot(v[0], v[1]);
  return len > 1e-6 ? [v[0]/len, v[1]/len] : [1,0];
}
function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}
for (let i = 0; i < segCount; i++) {
  const p0 = norm[i];
  const p1 = norm[i + 1];
  segments.set(p0.concat(p1), i * 4);

  // join angle: 이전 방향과 현 방향의 bisector
  let cosA = 1.0, sinA = 0.0;
  if (i > 0) {
    const prev = norm[i - 1];
    const dir0 = normalizeVec2([p0[0] - prev[0], p0[1] - prev[1]]);
    const dir1 = normalizeVec2([p1[0] - p0[0], p1[1] - p0[1]]);
    const dot = clamp(dir0[0]*dir1[0] + dir0[1]*dir1[1], -1, 1);
    const angle = Math.acos(dot);
    sinA = Math.sin(angle);
    cosA = Math.cos(angle);
    // 외적 음수면 방향 뒤집기
    const cross = dir0[0]*dir1[1] - dir0[1]*dir1[0];
    if (cross < 0) sinA = -sinA;
  }
  joinAngles.set([cosA, sinA], i * 2);
}

// ======= 쿼드 버퍼 (정적 4점) =======
const quadVerts = new Float32Array([
  -1, -1, // 0: 좌하
  -1,  1, // 1: 좌상
   1, -1, // 2: 우하
   1,  1, // 3: 우상
]);
const quadBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

// ======= 인덱스 =======
const indices = new Uint16Array([0, 1, 2, 2, 1, 3]);
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

// ======= 인스턴스 버퍼 =======
function bindInstancedBuffer(name, buf, size, stride, offset, divisor) {
  const loc = gl.getAttribLocation(program, name);
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, size, gl.FLOAT, false, stride, offset);
  ext.vertexAttribDivisorANGLE(loc, divisor);
}

const segBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, segBuf);
gl.bufferData(gl.ARRAY_BUFFER, segments, gl.STATIC_DRAW);

const joinBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, joinBuf);
gl.bufferData(gl.ARRAY_BUFFER, joinAngles, gl.STATIC_DRAW);

bindInstancedBuffer("a_position", quadBuffer, 2, 0, 0, 0);
bindInstancedBuffer("a_segmentStart", segBuf, 2, 16, 0, 1);
bindInstancedBuffer("a_segmentEnd", segBuf, 2, 16, 8, 1);
bindInstancedBuffer("a_joinAngles", joinBuf, 2, 0, 0, 1);

// ======= uniform =======
gl.uniform2f(gl.getUniformLocation(program, "u_viewSize"), canvas.width, canvas.height);
gl.uniform1f(gl.getUniformLocation(program, "u_halfWidth"), 12.0);    // px 단위 두께
gl.uniform1f(gl.getUniformLocation(program, "u_miterLimit"), 4.0);    // miter limit

// ======= 그리기 =======
gl.clear(gl.COLOR_BUFFER_BIT);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
ext.drawElementsInstancedANGLE(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, segCount);
</script>
</body>
</html>
