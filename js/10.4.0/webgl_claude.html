<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebGL Thick Dashed Line (Improved)</title>
  <style>
    canvas { border: 1px solid black; }
    .controls {
      margin: 10px 0;
    }
    label {
      margin-right: 15px;
    }
  </style>
</head>
<body>
<div class="controls">
  <label>Dash Length: <input type="range" id="dashLength" min="10" max="80" value="30"></label>
  <label>Gap Length: <input type="range" id="gapLength" min="5" max="50" value="15"></label>
  <label>Line Thickness: <input type="range" id="thickness" min="2" max="20" value="8"></label>
</div>
<canvas id="canvas" width="500" height="400"></canvas>
<script>
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl');
if (!gl) {
  alert('WebGL not supported');
  throw new Error('WebGL not supported');
}

// ------------------ Vertex & Fragment Shaders ------------------
const vertexShaderSource = `
  attribute vec2 a_position;     // vertex position in pixels
  attribute vec2 a_lineStart;    // start point of current line segment
  attribute vec2 a_lineEnd;      // end point of current line segment
  attribute float a_segmentStart; // distance where this segment starts
  attribute float a_side;        // -1 or +1 to indicate which side of line
  
  uniform vec2 u_resolution;
  uniform float u_thickness;
  
  varying vec2 v_lineStart;
  varying vec2 v_lineEnd;
  varying float v_segmentStart;
  varying float v_distanceAlongSegment;
  varying vec2 v_position;
  
  void main() {
    // Convert to clip space
    vec2 clip = (a_position / u_resolution) * 2.0 - 1.0;
    gl_Position = vec4(clip, 0.0, 1.0);
    
    // Pass through to fragment shader
    v_lineStart = a_lineStart;
    v_lineEnd = a_lineEnd;
    v_segmentStart = a_segmentStart;
    v_position = a_position;
    
    // Calculate distance along this segment
    vec2 segmentVec = a_lineEnd - a_lineStart;
    float segmentLength = length(segmentVec);
    
    // Project current position onto the line segment
    vec2 toPoint = a_position - a_lineStart;
    float projectionLength = dot(toPoint, segmentVec) / segmentLength;
    v_distanceAlongSegment = projectionLength;
  }
`;

const fragmentShaderSource = `
  precision mediump float;
  
  uniform float u_dashLength;
  uniform float u_gapLength;
  uniform vec3 u_color;
  
  varying vec2 v_lineStart;
  varying vec2 v_lineEnd;
  varying float v_segmentStart;
  varying float v_distanceAlongSegment;
  varying vec2 v_position;
  
  void main() {
    // Calculate total distance from start of path
    float totalDistance = v_segmentStart + v_distanceAlongSegment;
    
    // Calculate dash pattern
    float patternLength = u_dashLength + u_gapLength;
    float patternPos = mod(totalDistance, patternLength);
    
    // Check if we're in a dash or gap
    if (patternPos > u_dashLength) {
      discard;
    }
    
    gl_FragColor = vec4(u_color, 1.0);
  }
`;

// ------------------ Shader Setup ------------------
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function createProgram(gl, vs, fs) {
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    return null;
  }
  return program;
}

const vShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = createProgram(gl, vShader, fShader);

// ------------------ Path Data ------------------
const paths = [
  [[20,100],[80,120],[140,80],[200,150],[250,100],[300,180],[350,120],[420,160]]
];

// ------------------ Geometry Generation ------------------
function generateThickLineGeometry(points, thickness) {
  const halfThickness = thickness * 0.5;
  const vertices = [];
  const lineStarts = [];
  const lineEnds = [];
  const segmentStarts = [];
  const sides = [];
  const indices = [];
  
  // Calculate cumulative distances
  let cumulativeDistance = 0;
  const distances = [0];
  
  for (let i = 1; i < points.length; i++) {
    const dx = points[i][0] - points[i-1][0];
    const dy = points[i][1] - points[i-1][1];
    cumulativeDistance += Math.sqrt(dx*dx + dy*dy);
    distances.push(cumulativeDistance);
  }
  
  let vertexIndex = 0;
  
  // Generate geometry for each segment
  for (let i = 0; i < points.length - 1; i++) {
    const p1 = points[i];
    const p2 = points[i + 1];
    const segmentDistance = distances[i];
    
    // Calculate perpendicular vector
    const dx = p2[0] - p1[0];
    const dy = p2[1] - p1[1];
    const length = Math.sqrt(dx*dx + dy*dy);
    const nx = -dy / length * halfThickness; // perpendicular
    const ny = dx / length * halfThickness;
    
    // Create 4 vertices for this segment (quad)
    const v1 = [p1[0] + nx, p1[1] + ny]; // top-left
    const v2 = [p1[0] - nx, p1[1] - ny]; // bottom-left  
    const v3 = [p2[0] + nx, p2[1] + ny]; // top-right
    const v4 = [p2[0] - nx, p2[1] - ny]; // bottom-right
    
    // Add vertices
    vertices.push(v1[0], v1[1], v2[0], v2[1], v3[0], v3[1], v4[0], v4[1]);
    
    // Add line segment info for each vertex
    for (let j = 0; j < 4; j++) {
      lineStarts.push(p1[0], p1[1]);
      lineEnds.push(p2[0], p2[1]);
      segmentStarts.push(segmentDistance);
      sides.push(j < 2 ? -1 : 1); // left side vs right side
    }
    
    // Add indices for two triangles
    indices.push(
      vertexIndex, vertexIndex + 1, vertexIndex + 2,
      vertexIndex + 1, vertexIndex + 3, vertexIndex + 2
    );
    
    vertexIndex += 4;
  }
  
  return {
    vertices: new Float32Array(vertices),
    lineStarts: new Float32Array(lineStarts),
    lineEnds: new Float32Array(lineEnds),
    segmentStarts: new Float32Array(segmentStarts),
    sides: new Float32Array(sides),
    indices: new Uint16Array(indices)
  };
}

// ------------------ Render Function ------------------
function render() {
  const dashLength = parseFloat(document.getElementById('dashLength').value);
  const gapLength = parseFloat(document.getElementById('gapLength').value);
  const thickness = parseFloat(document.getElementById('thickness').value);
  
  // Generate geometry
  let allVertices = [];
  let allLineStarts = [];
  let allLineEnds = [];
  let allSegmentStarts = [];
  let allSides = [];
  let allIndices = [];
  let indexOffset = 0;
  
  for (const path of paths) {
    const geom = generateThickLineGeometry(path, thickness);
    
    // Concatenate arrays
    allVertices.push(...geom.vertices);
    allLineStarts.push(...geom.lineStarts);
    allLineEnds.push(...geom.lineEnds);
    allSegmentStarts.push(...geom.segmentStarts);
    allSides.push(...geom.sides);
    
    // Adjust indices
    for (let i = 0; i < geom.indices.length; i++) {
      allIndices.push(geom.indices[i] + indexOffset);
    }
    indexOffset += geom.vertices.length / 2; // 2 floats per vertex
  }
  
  // Create buffers
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allVertices), gl.STATIC_DRAW);
  
  const lineStartBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, lineStartBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allLineStarts), gl.STATIC_DRAW);
  
  const lineEndBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, lineEndBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allLineEnds), gl.STATIC_DRAW);
  
  const segmentStartBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, segmentStartBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allSegmentStarts), gl.STATIC_DRAW);
  
  const sideBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, sideBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allSides), gl.STATIC_DRAW);
  
  const indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(allIndices), gl.STATIC_DRAW);
  
  // Setup program
  gl.useProgram(program);
  
  // Bind attributes
  const positionLoc = gl.getAttribLocation(program, 'a_position');
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
  
  const lineStartLoc = gl.getAttribLocation(program, 'a_lineStart');
  gl.bindBuffer(gl.ARRAY_BUFFER, lineStartBuffer);
  gl.enableVertexAttribArray(lineStartLoc);
  gl.vertexAttribPointer(lineStartLoc, 2, gl.FLOAT, false, 0, 0);
  
  const lineEndLoc = gl.getAttribLocation(program, 'a_lineEnd');
  gl.bindBuffer(gl.ARRAY_BUFFER, lineEndBuffer);
  gl.enableVertexAttribArray(lineEndLoc);
  gl.vertexAttribPointer(lineEndLoc, 2, gl.FLOAT, false, 0, 0);
  
  const segmentStartLoc = gl.getAttribLocation(program, 'a_segmentStart');
  gl.bindBuffer(gl.ARRAY_BUFFER, segmentStartBuffer);
  gl.enableVertexAttribArray(segmentStartLoc);
  gl.vertexAttribPointer(segmentStartLoc, 1, gl.FLOAT, false, 0, 0);
  
  const sideLoc = gl.getAttribLocation(program, 'a_side');
  gl.bindBuffer(gl.ARRAY_BUFFER, sideBuffer);
  gl.enableVertexAttribArray(sideLoc);
  gl.vertexAttribPointer(sideLoc, 1, gl.FLOAT, false, 0, 0);
  
  // Set uniforms
  gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), canvas.width, canvas.height);
  gl.uniform1f(gl.getUniformLocation(program, 'u_thickness'), thickness);
  gl.uniform1f(gl.getUniformLocation(program, 'u_dashLength'), dashLength);
  gl.uniform1f(gl.getUniformLocation(program, 'u_gapLength'), gapLength);
  gl.uniform3f(gl.getUniformLocation(program, 'u_color'), 0.2, 0.7, 1.0);
  
  // Render
  gl.clearColor(0.1, 0.1, 0.1, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.drawElements(gl.TRIANGLES, allIndices.length, gl.UNSIGNED_SHORT, 0);
}

// Event listeners
document.getElementById('dashLength').addEventListener('input', render);
document.getElementById('gapLength').addEventListener('input', render);
document.getElementById('thickness').addEventListener('input', render);

// Initial render
render();
</script>
</body>
</html>
