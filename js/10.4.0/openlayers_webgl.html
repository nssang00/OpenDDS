<!doctype html><html lang="ko"><head>
<meta charset="utf-8">
<title>OpenLayers line shader – instanced-quad demo</title>
<style>html,body,canvas{margin:0;height:100%;width:100%;background:#111}</style>
</head><body>
<canvas id="gl"></canvas>
<script>
/*──────────────────── 0. GL ────────────────────*/
const canvas=document.getElementById('gl');
const gl=canvas.getContext('webgl2');
if(!gl){alert('WebGL2 필요');throw 0;}

/*──────────────────── 1. 경로 데이터 ────────────────────*/
const ll=[ /* 질문과 동일 lon,lat 배열 */ ];
const Lx=ll.map(p=>p[0]), Ly=ll.map(p=>p[1]);
const minX=Math.min(...Lx), maxX=Math.max(...Lx);
const minY=Math.min(...Ly), maxY=Math.max(...Ly);
const nx=x=>(x-minX)/(maxX-minX);
const ny=y=>(maxY-y)/(maxY-minY);        // y 뒤집기

/*──────────────────── 2. 세그먼트 단위 인스턴스 배열 ────────────────────
   layout(location):
   1 a_segmentStart 2 | 2 a_segmentEnd 2 | 3 a_measureStart 1 | 4 a_measureEnd 1 |
   5 a_parameters 1   | 6 a_distance 1   | 7 a_joinAngles 2   |
   8 a_hitColor 4     | 9 a_prop_layer 1 */
const segN=ll.length-1;
const inst=new Float32Array(segN*15);
let acc=0;
const ang=(ax,ay,bx,by,cx,cy)=>{
  const ux=ax-bx, uy=ay-by, vx=cx-bx, vy=cy-by;
  return Math.atan2(ux*vy-uy*vx, ux*vx+uy*vy);
};
for(let i=0;i<segN;i++){
  const [L0,A0]=ll[i], [L1,A1]=ll[i+1];
  const sx=nx(L0), sy=ny(A0), ex=nx(L1), ey=ny(A1);
  const dx=ex-sx, dy=ey-sy, segLen=Math.hypot(dx,dy);
  const prev=i?ll[i-1]:null, next=i<segN-1?ll[i+2]:null;
  const a0=prev?ang(nx(prev[0]),ny(prev[1]),sx,sy,ex,ey):-3.14;
  const a1=next?ang(sx,sy,ex,ey,nx(next[0]),ny(next[1])):-3.14;
  const o=i*15;
  inst.set([sx,sy,ex,ey, acc, acc+segLen, 0, segLen, a0,a1, 1,0,0,1, 0], o);
  acc+=segLen;
}

/*──────────────────── 3. 정적 쿼드 VBO ────────────────────*/
const quad=new Float32Array([-1,-1,-1,1, 1,-1, 1,1]);
const vboQuad=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vboQuad);
gl.bufferData(gl.ARRAY_BUFFER,quad,gl.STATIC_DRAW);

/* 인스턴스 VBO */
const vboInst=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vboInst);
gl.bufferData(gl.ARRAY_BUFFER,inst,gl.STATIC_DRAW);

/*──────────────────── 4. 셰이더 소스 (OpenLayers 원본 +a_extrude) ────────────────────*/
const VERT_SRC=`#version 300 es
#define GL_FRAGMENT_PRECISION_HIGH
precision highp float;
uniform mat4 u_projectionMatrix;
uniform mat4 u_screenToWorldMatrix;
uniform vec2 u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
uniform float u_rotation;
uniform vec4 u_renderExtent;
uniform vec2 u_patternOrigin;
uniform float u_depth;
uniform mediump int u_hitDetection;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;
float currentLineMetric = 0.;

uniform vec2 u_texture1269122425_size;
uniform sampler2D u_texture1269122425;
uniform sampler2D u_depthMask;
uniform float u_tileZoomLevel;

/* ─── 정적 쿼드 ─── */
layout(location=0) in vec2 a_extrude;

/* ─── instanced attributes ─── */
layout(location=1) in vec2 a_segmentStart;
layout(location=2) in vec2 a_segmentEnd;
layout(location=3) in float a_measureStart;
layout(location=4) in float a_measureEnd;
layout(location=5) in float a_parameters;   /* extrude 비트는 사용 안 함 */
layout(location=6) in float a_distance;
layout(location=7) in vec2 a_joinAngles;
layout(location=8) in vec4 a_hitColor;
layout(location=9) in float a_prop_layer;

/* varyings */
out vec2 v_segmentStart;
out vec2 v_segmentEnd;
out float v_angleStart;
out float v_angleEnd;
out float v_width;
out vec4 v_hitColor;
out float v_distanceOffsetPx;
out float v_measureStart;
out float v_measureEnd;
out float v_prop_layer;

/* helper (원본 그대로) */
vec2 worldToPx(vec2 w){ vec4 s=u_projectionMatrix*vec4(w,0.0,1.0); return (0.5*s.xy+0.5)*u_viewportSizePx; }
vec4 pxToScreen(vec2 p){ vec2 s=2.0*p/u_viewportSizePx-1.0; return vec4(s,u_depth,1.0); }
bool isCap(float a){return a<-0.1;}
vec2 getJoinOffsetDirection(vec2 n,float a){ float h=a/2.0,c=cos(h),s=sin(h); vec2 b=vec2(s*n.x+c*n.y,-c*n.x+s*n.y); return b*(1.0/s); }
vec2 getOffsetPoint(vec2 p,vec2 n,float a,float off){ return (cos(a)>0.998||isCap(a))?p-n*off:p-getJoinOffsetDirection(n,a)*off; }

void main(){
  v_angleStart=a_joinAngles.x;
  v_angleEnd  =a_joinAngles.y;

  /* ── (추가) vertexNumber를 a_extrude 부호로 계산 ── */
  float vertexNumber = (a_extrude.x<0.?0.:2.) + (a_extrude.y>0.?0.:1.);
  currentLineMetric  = vertexNumber < 1.5 ? a_measureStart : a_measureEnd;
  float angleTangentSum = 0.0;              /* extrude비트 미사용 → 0 */

  float lineWidth=20.0;
  float lineOffsetPx=0.0;

  vec2 sPx=worldToPx(a_segmentStart);
  vec2 ePx=worldToPx(a_segmentEnd);
  vec2 tPx=normalize(ePx-sPx);
  vec2 nPx=vec2(-tPx.y,tPx.x);
  sPx=getOffsetPoint(sPx,nPx,v_angleStart,lineOffsetPx);
  ePx=getOffsetPoint(ePx,nPx,v_angleEnd ,lineOffsetPx);

  float normalDir  =(vertexNumber<0.5||vertexNumber>1.5)?1.:-1.;
  float tangentDir =(vertexNumber<1.5)?1.:-1.;
  float ang        =(vertexNumber<1.5)?v_angleStart:v_angleEnd;
  vec2  basePx     =(vertexNumber<1.5)?sPx:ePx;

  vec2 joinDir = (cos(ang)>0.985||isCap(ang))
               ? nPx*normalDir - tPx*tangentDir
               : getJoinOffsetDirection(nPx*normalDir,ang);

  vec2 posPx = basePx + joinDir*(lineWidth*0.5+1.);
  gl_Position = pxToScreen(posPx);

  v_segmentStart=sPx; v_segmentEnd=ePx; v_width=lineWidth;
  v_hitColor=a_hitColor;
  v_distanceOffsetPx=a_distance/u_resolution;
  v_measureStart=a_measureStart; v_measureEnd=a_measureEnd;
  v_prop_layer=a_prop_layer;
}`;
const FRAG_SRC=`#version 300 es
#define GL_FRAGMENT_PRECISION_HIGH
precision highp float;
uniform mat4 u_projectionMatrix;
uniform mat4 u_screenToWorldMatrix;
uniform vec2 u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
uniform float u_rotation;
uniform vec4 u_renderExtent;
uniform vec2 u_patternOrigin;
uniform float u_depth;
uniform mediump int u_hitDetection;

out vec4 fragColor;

/* varyings */
in vec2 v_segmentStart;
in vec2 v_segmentEnd;
in float v_angleStart;
in float v_angleEnd;
in float v_width;
in vec4 v_hitColor;
in float v_distanceOffsetPx;
in float v_measureStart;
in float v_measureEnd;
in float v_prop_layer;

void main(){
  /* 단순 컬러 출력 – OpenLayers distance-field 로직 생략 */
  fragColor = vec4(0.08,0.8,1.0,1.0);
}`;
const compile=(t,s)=>{const sh=gl.createShader(t);gl.shaderSource(sh,s);gl.compileShader(sh);
 if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(sh);return sh;};
const prog=gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,VERT_SRC));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,FRAG_SRC));
['a_extrude','a_segmentStart','a_segmentEnd','a_measureStart','a_measureEnd',
 'a_parameters','a_distance','a_joinAngles','a_hitColor','a_prop_layer']
.forEach((n,i)=>gl.bindAttribLocation(prog,i,n));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog,gl.LINK_STATUS))throw gl.getProgramInfoLog(prog);
gl.useProgram(prog);

/*──────────────────── 5. VAO ────────────────────*/
const vao=gl.createVertexArray();gl.bindVertexArray(vao);
/* location 0 : a_extrude (divisor 0) */
gl.bindBuffer(gl.ARRAY_BUFFER,vboQuad);
gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
/* instanced attributes */
gl.bindBuffer(gl.ARRAY_BUFFER,vboInst);
const STR=60;
function inst(loc,size,off){
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc,size,gl.FLOAT,false,STR,off);
  gl.vertexAttribDivisor(loc,1);
}
inst(1,2,0);  inst(2,2,8); inst(3,1,16); inst(4,1,20);
inst(5,1,24); inst(6,1,28); inst(7,2,32);
inst(8,4,40); inst(9,1,56);

/*──────────────────── 6. 필수 유니폼 설정 ────────────────────*/
const loc=(n)=>gl.getUniformLocation(prog,n);
const proj=[ 2,0,0,-1, 0,2,0,-1, 0,0,1,0, 0,0,0,1 ];
gl.uniformMatrix4fv(loc('u_projectionMatrix'),false,new Float32Array(proj));
gl.uniformMatrix4fv(loc('u_screenToWorldMatrix'),false,new Float32Array(proj));
gl.uniform1f(loc('u_pixelRatio'),1);
gl.uniform1f(loc('u_resolution'),1);
gl.uniform1f(loc('u_depth'),0);
gl.uniform1i(loc('u_hitDetection'),0);
gl.uniform4f(loc('u_renderExtent'),0,0,0,0);
/* viewport-size & halfWidth 는 resize 에서 */

function resize(){
 canvas.width=innerWidth; canvas.height=innerHeight;
 gl.viewport(0,0,canvas.width,canvas.height);
 gl.uniform2f(loc('u_viewportSizePx'),canvas.width,canvas.height);
}
addEventListener('resize',resize); resize();
gl.uniform1f(loc('u_halfWidth'),8);   // line half-width 8px

/*──────────────────── 7. 그리기 ────────────────────*/
gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
gl.bindVertexArray(vao);
gl.drawArraysInstanced(gl.TRIANGLE_STRIP,0,4,segN);
</script>
</body></html>
